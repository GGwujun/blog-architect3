<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect3/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect3";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>09 | 用户态跟踪：如何使用 eBPF 排查应用程序？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/ebpf核心技术与实战/04.实战进阶篇/03" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词/01"><span>开篇词 | 想要洞悉系统底层的黑盒？先掌握 eBPF！</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇">02.学习准备篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/01"><span>01｜技术概览：eBPF 的发展历程及工作原理</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/02"><span>02 | 先利其器：如何高效学习 eBPF？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇">03.基础入门篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/01"><span>03 | 初窥门径：开发并运行你的第一个 eBPF 程序</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02"><span>04 | 运行原理：eBPF 是一个新的虚拟机吗？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/03"><span>05 | 编程接口：eBPF 程序是怎么跟内核进行交互的？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/04"><span>06 | 事件触发：各类 eBPF 程序的触发机制及其应用场景</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇">04.实战进阶篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/01"><span>07 | 内核跟踪（上）：如何查询内核中的跟踪点？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/02"><span>08｜内核跟踪（下）：开发内核跟踪程序的进阶方法</span></a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03"><span>09 | 用户态跟踪：如何使用 eBPF 排查应用程序？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/04"><span>10 | 网络跟踪：如何使用 eBPF 排查网络问题？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/05"><span>11 | 容器安全：如何使用 eBPF 增强容器安全？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06"><span>12｜高性能网络实战（上）：如何开发一个负载均衡器？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07"><span>13｜高性能网络实战（下）：如何完善负载均衡器？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结">05.阶段总结</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/01"><span>阶段总结｜实用 eBPF 工具及最新开源项目总结</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/02"><span>未来可期｜邀你与 eBPF 共赴一场技术革新之约</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇">06.技术雷达篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇/01"><span>难点解析｜eBPF 开发环境搭建及内核编译详解</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇/01"><span>加餐｜李程远：谈谈 eBPF 在云原生中的纵与横</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/summary">ebpf核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="如何查询用户进程跟踪点？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#如何查询用户进程跟踪点"><span>如何查询用户进程跟踪点？</span></a></li><li title="编程语言会影响 eBPF 的跟踪吗？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#编程语言会影响-ebpf-的跟踪吗"><span>编程语言会影响 eBPF 的跟踪吗？</span></a></li><li title="跟踪编译型语言应用程序" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#跟踪编译型语言应用程序"><span>跟踪编译型语言应用程序</span></a></li><li title="跟踪解释型语言应用程序" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#跟踪解释型语言应用程序"><span>跟踪解释型语言应用程序</span></a></li><li title="跟踪即时编译型语言应用程序" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#跟踪即时编译型语言应用程序"><span>跟踪即时编译型语言应用程序</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="09--用户态跟踪如何使用-ebpf-排查应用程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#09--用户态跟踪如何使用-ebpf-排查应用程序"><span class="icon icon-link"></span></a>09 | 用户态跟踪：如何使用 eBPF 排查应用程序？</h1><p>你好，我是倪朋飞。</p><p>前面两讲，我带你梳理了查询 eBPF 跟踪点的常用方法，并以短时进程的跟踪为例，通过 bpftrace、BCC 和 libbpf 等三种方法实现了短时进程的跟踪程序。学完这些内容，我想你已经可以根据自己的实际需求，查询到内核跟踪点或内核函数，并自己开发一个 eBPF 内核跟踪程序。</p><p>也许你想问：我们能不能利用与跟踪内核状态类似的方法，去跟踪用户空间的进程呢？答案是肯定的。只要把内核态跟踪使用的 <code>kprobe</code> 和 <code>tracepoint</code> 替换成 <code>uprobe</code> ，或者用户空间定义的静态跟踪点（User Statically Defined Tracing，简称 USDT），并找出用户进程需要跟踪的函数，作为 eBPF 程序的挂载点，你就可以去跟踪用户进程的内部状态。</p><p>那具体该怎么做呢？今天，我就带你一起来看看，如何使用 eBPF 去跟踪用户进程的执行状态。</p><h2 id="如何查询用户进程跟踪点"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#如何查询用户进程跟踪点"><span class="icon icon-link"></span></a>如何查询用户进程跟踪点？</h2><p>在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484207">07讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中我曾提到，在跟踪内核的状态之前，你需要利用内核提供的调试信息查询内核函数、内核跟踪点以及性能事件等。类似地，在跟踪应用进程之前，你也需要知道<strong>这个进程所对应的二进制文件中提供了哪些可用的跟踪点</strong>。那么，从哪里可以找到这些信息呢？如果你使用 GDB 之类的应用调试过程序，这时应该已经想到了，那就是<strong>应用程序二进制文件中的调试信息</strong>。</p><p>在静态语言的编译过程中，通常你可以加上 <code>-g</code> 选项保留调试信息。这样，源代码中的函数、变量以及它们对应的代码行号等信息，就以 <a target="_blank" rel="noopener noreferrer" href="https://dwarfstd.org/">DWARF<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Debugging With Attributed Record Formats，Linux 和类 Unix 平台最主流的调试信息格式）格式存储到了编译后的二进制文件中。</p><p>有了调试信息，你就可以通过 <a target="_blank" rel="noopener noreferrer" href="https://man7.org/linux/man-pages/man1/readelf.1.html">readelf<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://man7.org/linux/man-pages/man1/objdump.1.html">objdump<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a target="_blank" rel="noopener noreferrer" href="https://man7.org/linux/man-pages/man1/nm.1.html">nm<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 等工具，查询可用于跟踪的函数、变量等符号列表。比如，我经常使用 <code>readelf</code> 命令，查询二进制文件的基本信息。在终端中执行下面的命令，就可以查询 <a target="_blank" rel="noopener noreferrer" href="https://www.gnu.org/software/libc/">libc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 动态链接库中的符号表：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 查询符号表（RHEL8系统中请把动态库路径替换为/usr/lib64/libc.so.6）</span></div><div class="token-line"><span class="token plain">    readelf -Ws /usr/lib/x86_64-linux-gnu/libc.so.6</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 查询USDT信息（USDT信息位于ELF文件的notes段）</span></div><div class="token-line"><span class="token plain">    readelf -n /usr/lib/x86_64-linux-gnu/libc.so.6</span></div></pre></div><p>当然，我们 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484207">07讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中提到的 bpftrace 工具也可以用来查询 uprobe 和 USDT 跟踪点，其查询格式如下所示（同样支持 <code>*</code> 通配符过滤）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 查询uprobe（RHEL8系统中请把动态库路径替换为/usr/lib64/libc.so.6）</span></div><div class="token-line"><span class="token plain">    bpftrace -l &#x27;uprobe:/usr/lib/x86_64-linux-gnu/libc.so.6:*&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 查询USDT</span></div><div class="token-line"><span class="token plain">    bpftrace -l &#x27;usdt:/usr/lib/x86_64-linux-gnu/libc.so.6:*&#x27;</span></div></pre></div><p>同内核跟踪点类似，你也可以加上 <code>-v</code> 选项查询用户探针的参数格式。不过需要再次强调的是，<strong>想要通过二进制文件查询符号表和参数定义，必须在编译的时候保留 DWARF 调试信息</strong>。</p><p>除了符号表之外，理论上你可以把 uprobe 插桩到二进制文件的任意地址。不过这要求你对应用程序 ELF 格式的地址空间非常熟悉，并且具体的地址会随着应用的迭代更新而发生变化。所以，在需要跟踪地址的场景中，一定要记得去 ELF 二进制文件动态获取地址信息。</p><p>另外需要提醒你的是，<strong>uprobe 是基于文件的。当文件中的某个函数被跟踪时，除非对进程 PID 进行了过滤，默认所有使用到这个文件的进程都会被插桩。</strong></p><h2 id="编程语言会影响-ebpf-的跟踪吗"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#编程语言会影响-ebpf-的跟踪吗"><span class="icon icon-link"></span></a>编程语言会影响 eBPF 的跟踪吗？</h2><p>如果你了解过不同的编程语言，看到这里你肯定会想到，这些查询跟踪点信息的方法很可能是跟编程语言相关的。C 语言和 Python 语言是我们课程的学习基础，也是前面几讲的案例中反复使用的编程语言，我相信你至少已经对它们有了简单的了解。这里我们对比下这两种编程语言在运行方式上的区别：</p><ul><li>C 语言程序需要编译为二进制文件之后再执行，编译时加上 <code>-g</code> 选项就可以在最终的二进制文件中保留调试信息；</li><li>Python 语言程序则是一个文本文件，不需要 C 语言那样的编译过程，而是由 Python 解释器进行语法分析后执行。因而，上述<code>readelf</code> 等工具没法从 <code>python</code> 二进制文件中直接读取到应用程序的调试信息。</li></ul><p>当然，C 和 Python 只是我们课程中使用的两种编程语言，实际的编程语言种类要多得多。如果把常用的编程语言进行归类，按照其运行原理，我认为大致上可以分为三类：</p><ul><li>第一类是 C、C加加、Golang 等编译为机器码后再执行的<strong>编译型语言</strong>。这类编程语言开发的程序，通常会编译成 ELF 格式的二进制文件，包含了保存在寄存器或栈中的函数参数和返回值，因而可以直接通过二进制文件中的符号进行跟踪。</li><li>第二类是 Python、Bash、Ruby 等通过解释器语法分析之后再执行的<strong>解释型语言</strong>。这类编程语言开发的程序，无法直接从语言运行时的二进制文件中获取应用程序的调试信息，通常需要跟踪解释器的函数，再从其参数中获取应用程序的运行细节。</li><li>最后一类是 Java、.Net、JavaScript 等先编译为字节码，再由即时编译器（JIT）编译为机器码执行的<strong>即时编译型语言</strong>。同解释型语言类似，这类编程语言无法直接从语言运行时的二进制文件中获取应用程序的调试信息。跟踪 JIT 编程语言开发的程序是最困难的，因为 JIT 编译的状态只存在于内存中。</li></ul><p>对比这几类编程语言，你可以发现，编程语言的类型对 eBPF 跟踪也有非常大的影响，不同类型编程语言开发的应用程序，其跟踪过程和难度也不相同。接下来，我就用几个案例带你一起来看看每一类编程语言的跟踪方法。</p><h2 id="跟踪编译型语言应用程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#跟踪编译型语言应用程序"><span class="icon icon-link"></span></a>跟踪编译型语言应用程序</h2><p>由于可以直接从调试信息中获取到符号（用于跟踪函数）和帧指针（用于跟踪调用栈），编译型语言开发的应用程序是比较容易跟踪的。</p><p>不过需要注意的是，大部分编译型语言遵循 <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI（Application Binary Interface）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 调用规范，函数的参数和返回值都存放在寄存器中。而 Go 1.17 之前使用的是 <a target="_blank" rel="noopener noreferrer" href="https://9p.io/sys/doc/asm.html">Plan 9<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 调用规范，函数的参数和返回值都存放在堆栈中；直到 1.17， Go 才从 Plan 9 切换到 ABI 调用规范。所以，在跟踪函数参数和返回值时，你需要<strong>首先区分编程语言的调用规范</strong>，然后再去寄存器或堆栈中读取函数的参数和返回值。</p><p>此外，<strong>调试信息并非一定要内置于最终分发的应用程序二进制文件中，它们也可以放到独立的调试文件存储</strong>。为了减少应用程序二进制文件的大小，通常会把调试信息从二进制文件中剥离出来，保存到 <code>&lt;应用名&gt;.debuginfo</code> 或者 <code>&lt;build-id&gt;.debug</code> 文件中，后续排查问题需要用到时再安装。</p><p>比如，在 RHEL 和 Ubuntu 等常见的 Linux 发行版中，调试信息跟应用程序通常是两个不同的软件包。而对很多开发者来说，每次编译和发布应用程序之前，通常都需要执行一下 <code>strip</code> 命令，把调试信息删除后才发布到生产环境中。</p><p>这里给你个小提示：ELF 符号表包含 <code>.symtab</code>（应用本地的符号）和 <code>.dynsym</code>（调用到外部的符号），<code>strip</code> 命令实际上只是删除了 <code>.symtab</code> 的内容。</p><p>接下来，我就以每个 Linux 用户都会使用的 Bash 为例（Bash 是一个典型的 C 语言程序），带你一起看看，如何跟踪编译型语言应用程序的执行状态。</p><p>在服务器的维护过程中，系统维护人员都需要审计每个用户登录后都执行了哪些命令，以便事后排查问题时参考。由于登录后所有命令的执行都发生在 Bash 中，那么，有没有可能使用 eBPF 来跟踪 Bash 里面到底执行过什么命令呢？答案是肯定的。</p><p>在跟踪 Bash 之前，首先执行下面的命令，安装它的调试信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># Ubuntu</span></div><div class="token-line"><span class="token plain">    sudo apt install bash-dbgsym</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # RHEL</span></div><div class="token-line"><span class="token plain">    sudo debuginfo-install bash</span></div></pre></div><p>有了 Bash 调试信息之后，再执行下面的几步，查询 Bash 的符号表：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 第一步，查询 Build ID（用于关联调试信息）</span></div><div class="token-line"><span class="token plain">    readelf -n /usr/bin/bash | grep &#x27;Build ID&#x27;</span></div><div class="token-line"><span class="token plain">    # 输出示例为：</span></div><div class="token-line"><span class="token plain">    #     Build ID: 7b140b33fd79d0861f831bae38a0cdfdf639d8bc</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 第二步，找到调试信息对应的文件（调试信息位于目录/usr/lib/debug/.build-id中，上一步中得到的Build ID前两个字母为目录名）</span></div><div class="token-line"><span class="token plain">    ls /usr/lib/debug/.build-id/7b/140b33fd79d0861f831bae38a0cdfdf639d8bc.debug</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 第三步，从调试信息中查询符号表</span></div><div class="token-line"><span class="token plain">    readelf -Ws /usr/lib/debug/.build-id/7b/140b33fd79d0861f831bae38a0cdfdf639d8bc.debug</span></div></pre></div><p>参考 Bash 的<a target="_blank" rel="noopener noreferrer" href="https://git.savannah.gnu.org/cgit/bash.git/tree/lib/readline/readline.c?h=bash-5.1#n352">源代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，每条 Bash 命令在运行前，都会调用 <code>char</code><em><code>readline (const char</code></em><code>prompt)</code> 函数读取用户的输入，然后再去解析执行（Bash 自身是使用编译型语言 C 开发的，而 Bash 语言则是一种解释型语言）。</p><p>注意，<code>readline</code> 函数的参数是命令行提示符（通过环境变量 <code>PS1</code>、<code>PS2</code> 等设置），而返回值才是用户的输入。因而，我们只需要跟踪 <code>readline</code> 函数的返回值，也就是使用 <code>uretprobe</code> 跟踪。</p><p>bpftrace、BCC 以及 libbpf 等工具均支持 <code>uretprobe</code>，因而最简单的跟踪方法就是使用 bpftrace 的单行命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftrace -e &#x27;uretprobe:/usr/bin/bash:readline { printf(&quot;User %d executed \&quot;%s\&quot; command\n&quot;, uid, str(retval)); }&#x27;</span></div></pre></div><p>这个命令中具体内容的作用如下：</p><ul><li><code>uretprobe:/usr/bin/bash:readline</code> 设置跟踪类型为 <code>uretprobe</code>，跟踪的二进制文件为 <code>/usr/bin/bash</code>，跟踪符号为 <code>readline</code>；</li><li>中括号里的内容为 uretprobe 的处理函数；</li><li>处理函数中，<code>uid</code> 和 <code>retval</code> 是两个内置变量，分别表示用户 UID 以及返回值；</li><li><code>str</code> 用于从指针中读取字符串， <code>str(retval)</code> 就是 Bash 中输入命令的字符串；</li><li><code>printf</code> 用于向终端中打印一个字符串。</li></ul><p>打开一个终端，并在新终端中执行 <code>ps</code> 命令，然后就会在第一个终端中看到如下的输出（即 UID 为 1000 的用户执行了 <code>ps</code> 命令）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Attaching 1 probe...</span></div><div class="token-line"><span class="token plain">    User 1000 executed &quot;ps&quot; command</span></div></pre></div><p>和上一讲的案例类似，这里我们也可以使用 BCC 和 libbpf 实现相同的跟踪程序。由于它们的实现逻辑是类似的，并且 BCC 提供了对初学者更友好的接口，所以接下来，我就以 BCC 为例，带你一起看看如何来跟踪用户空间的 Bash。</p><p>还记得用 BCC 来开发一个 eBPF 跟踪程序的具体步骤吗？如果你不记得，也没关系，我来带你简单回顾一下。BCC 的使用可以分为两部分：</p><ul><li>第一部分是用 C 语言开发的 eBPF 程序。在 eBPF 程序中，你可以利用 BCC 提供的<a target="_blank" rel="noopener noreferrer" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md">库函数和宏定义<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>简化你的处理逻辑。</li><li>第二部分是用 Python 语言开发的前端界面，其中包含 eBPF 程序加载、挂载到内核函数和跟踪点，以及通过 BPF 映射获取和打印执行结果等部分。在前端程序中，你同样可以利用 BCC 库来访问 BPF 映射。</li></ul><p>对于第一部分来说，我们要做的就是从 uretprobe 的处理函数中获取 <code>readline</code> 的返回值，然后提交到性能事件映射中。这里你可能想问：如何获取返回值呢？是不是已经有库函数可以直接拿过来用呢？对此，特别提醒你一点：<strong>当碰到不懂的问题，特别是不清楚接口调用的具体格式时，不要去互联网搜索，而是应该查询官方文档（或者源代码）<strong><strong>来</strong></strong>确认。</strong></p><p>对于 BCC 的 uretprobe 来说，其官方文档链接就是 <a target="_blank" rel="noopener noreferrer" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#5-uretprobes">uretprobes<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。根据这里的文档，uretprobe 处理函数的定义格式应该为 <code>function_name(struct pt_regs *ctx)</code>，而返回值可以通过宏 <code>PT_REGS_RC(ctx)</code> 来获取（实际上，kretprobe 也是采用相同的格式）。有了这些文档，就可以按照这里的函数格式来完成第一部分的开发了。代码如下所示，每一步我都加了详细的注释：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 包含头文件</span></div><div class="token-line"><span class="token plain">    #include &lt;uapi/linux/ptrace.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 定义数据结构和性能事件映射</span></div><div class="token-line"><span class="token plain">    struct data_t {</span></div><div class="token-line"><span class="token plain">        u32 uid;</span></div><div class="token-line"><span class="token plain">        char command[64];</span></div><div class="token-line"><span class="token plain">    };</span></div><div class="token-line"><span class="token plain">    BPF_PERF_OUTPUT(events);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // 定义uretprobe处理函数</span></div><div class="token-line"><span class="token plain">    int bash_readline(struct pt_regs *ctx)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        // 查询uid</span></div><div class="token-line"><span class="token plain">        struct data_t data = { };</span></div><div class="token-line"><span class="token plain">        data.uid = bpf_get_current_uid_gid();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 从PT_REGS_RC(ctx)读取返回值</span></div><div class="token-line"><span class="token plain">        bpf_probe_read_user(&amp;data.command, sizeof(data.command), (void *)PT_REGS_RC(ctx));</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 提交性能事件</span></div><div class="token-line"><span class="token plain">        events.perf_submit(ctx, &amp;data, sizeof(data));</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>从代码中你可以看到，eBPF 程序的结构跟上一讲基本类似，唯一需要注意的是函数的定义格式以及返回值的读取位置。将上述代码保存到 <code>bashreadline.c</code> 文件中，我们就完成了第一部分的开发。</p><p>有了 eBPF 程序之后，第二部分的 Python 前端也比较直观，代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 引入BCC库</span></div><div class="token-line"><span class="token plain">    from bcc import BPF</span></div><div class="token-line"><span class="token plain">    from time import strftime</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 加载eBPF 程序</span></div><div class="token-line"><span class="token plain">    b = BPF(src_file=&quot;bashreadline.c&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 挂载uretprobe</span></div><div class="token-line"><span class="token plain">    b.attach_uretprobe(name=&quot;/usr/bin/bash&quot;, sym=&quot;readline&quot;, fn_name=&quot;bash_readline&quot;)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 定义性能事件回调（输出时间、UID以及Bash中执行的命令）</span></div><div class="token-line"><span class="token plain">    def print_event(cpu, data, size):</span></div><div class="token-line"><span class="token plain">        event = b[&quot;events&quot;].event(data)</span></div><div class="token-line"><span class="token plain">        print(&quot;%-9s %-6d %s&quot; % (strftime(&quot;%H:%M:%S&quot;), event.uid, event.command.decode(&quot;utf-8&quot;)))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 打印头</span></div><div class="token-line"><span class="token plain">    print(&quot;%-9s %-6s %s&quot; % (&quot;TIME&quot;, &quot;UID&quot;, &quot;COMMAND&quot;))</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 绑定性能事件映射和输出函数，并从映射中循环读取数据</span></div><div class="token-line"><span class="token plain">    b[&quot;events&quot;].open_perf_buffer(print_event)</span></div><div class="token-line"><span class="token plain">    while 1:</span></div><div class="token-line"><span class="token plain">        try:</span></div><div class="token-line"><span class="token plain">            b.perf_buffer_poll()</span></div><div class="token-line"><span class="token plain">        except KeyboardInterrupt:</span></div><div class="token-line"><span class="token plain">            exit()</span></div></pre></div><p>可以看到，这部分的代码跟上一讲案例的结构也是类似的。主要的不同点在于，挂载 uretprobe 的时候调用了 <code>b.attach_uretprobe()</code> ，并在其参数中传入了二进制文件的路径 <code>name=&quot;/usr/bin/bash&quot;</code> ，以及要跟踪的符号 <code>sym=&quot;readline&quot;</code>。</p><p>在 BCC 的内部，当你挂载 uprobe 或者 uretprobe 到用户程序时，由于同一个符号可能出现多次，BCC 会首先查询该符号的所有地址，然后把 eBPF 程序挂载到所有不同的地址上。</p><p>如果你没有使用 BCC 等库，你就需要自己来实现类似的逻辑。而要实现它，还需要详细了解 ELF 文件格式，以及对应库函数的使用方法，这个难度就要大很多了。这也是我推荐你使用 BCC、libbpf 等库进行 eBPF 程序开发的原因。这些库已经帮你把很多繁杂且跟 eBPF 事件处理主要逻辑无关的部分实现好了，你只需要调用它们实现你最核心的 eBPF 处理逻辑即可。</p><p>将上述代码保存到 <code>bashreadline.py</code> ，然后执行 <code>sudo python3 bashreadline.py</code> ，我们就可以运行这个跟踪程序。打开一个新终端并运行 <code>ls</code> 命令，回到第一个终端，你就可以看到如下的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">TIME      UID    COMMAND</span></div><div class="token-line"><span class="token plain">    07:17:07  1000   ls</span></div></pre></div><p>从这里的例子中，你可以发现：编译型语言应用程序的跟踪与内核的跟踪是类似的，只不过是把跟踪类型从 kprobe 换成了 uprobe 或者 USDT（USDT 的例子我会在接下来的内容中讲到）。不同的地方在于符号信息：应用程序的符号信息可以存放在 ELF 二进制文件中，也可以以单独文件的形式，放到调试文件中；而内核的符号信息除了可以存放到内核二进制文件中之外，还会以 <code>/proc/kallsyms</code> 和 <code>/sys/kernel/debug</code> 等形式暴露到用户空间。</p><h2 id="跟踪解释型语言应用程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#跟踪解释型语言应用程序"><span class="icon icon-link"></span></a>跟踪解释型语言应用程序</h2><p>了解了编译型语言应用程序的跟踪方法之后，接下来，我们再来看看解释型语言应用程序又该如何跟踪。</p><p>上面我已经提到，你无法从解释型语言的二进制文件中直接获取应用程序的调试信息，而只能获得解释器本身的符号信息。所以，对于这类语言开发的应用程序，通常需要跟踪解释器内的函数，再从其参数中获取应用程序的运行细节。</p><p>对于各种解释型编程语言的二进制文件（如 Python、PHP 等），你可以使用类似编译型语言应用程序的跟踪点查询方法，查询它们在解释器层面的 uprobe 和 USDT 跟踪点。比如，对于 Python3 来说，你可以执行下面的命令查询：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftrace -l &#x27;*:/usr/bin/python3:*&#x27;</span></div></pre></div><p>命令执行后，你会得到 1500 多个跟踪点。接下来的难点在于，<strong>如何从这些解释器的跟踪点中找出应用程序的函数信息</strong>，所以你需要对解释器的运行原理有一定的了解。</p><p>既然我们这门课中的案例大量使用了 Python 这种解释型编程语言，那我们下面就来试试，能不能从 Python 解释器的跟踪点中，跟踪应用程序的函数执行过程。</p><p>实际上，根据 Python <a target="_blank" rel="noopener noreferrer" href="https://docs.python.org/zh-cn/3/howto/instrumentation.html">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，为其开启 USDT 跟踪点（编译选项为 <code>--with-dtrace</code>）之后，Python3 二进制文件中就会包含一系列的 USDT 跟踪点。这些跟踪点也可以通过 bpftrace 查询到：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ bpftrace -l &#x27;*:/usr/bin/python3:*&#x27;</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:audit</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:function__entry</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:function__return</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:gc__done</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:gc__start</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:import__find__load__done</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:import__find__load__start</span></div><div class="token-line"><span class="token plain">    usdt:/usr/bin/python3:python:line</span></div></pre></div><p>其中，跟函数调用相关的正是 <code>function__entry</code> 和 <code>function__return</code>，因而它们就可以用来跟踪函数的调用过程。根据 Python <a target="_blank" rel="noopener noreferrer" href="https://docs.python.org/zh-cn/3/howto/instrumentation.html#available-static-markers">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这两个函数的定义格式为：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 三个参数分别是文件名、函数名和行号</span></div><div class="token-line"><span class="token plain">    function__entry(str filename, str funcname, int lineno)</span></div><div class="token-line"><span class="token plain">    function__return(str filename, str funcname, int lineno)</span></div></pre></div><p>有了跟踪点的定义格式，我们就可以使用 eBPF 来跟踪这些函数。比如，对 <code>function__entry</code> 来说，执行下面的 bpftrace 单行命令，就可以跟踪 Python 函数的调用信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftrace -e &#x27;usdt:/usr/bin/python3:function__entry { printf(&quot;%s:%d %s\n&quot;, str(arg0), arg2, str(arg1))}&#x27;</span></div></pre></div><p>在这个命令中， <code>arg0</code>、 <code>arg1</code> 、 <code>arg2</code> 表示函数的三个参数。这条命令的含义就是把这几个参数拼接成 <code>文件名:行号 函数名</code> 的格式，然后再打印到终端上。</p><p>打开一个新终端，并执行下面的 Python 命令开启一个 http 服务：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">python3 -m http.server 8080</span></div></pre></div><p>然后，再回到第一个终端，就可以看到如下的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    /usr/lib/python3.9/socketserver.py:254 service_actions</span></div><div class="token-line"><span class="token plain">    /usr/lib/python3.9/selectors.py:403 select</span></div><div class="token-line"><span class="token plain">    /usr/lib/python3.9/socketserver.py:254 service_actions</span></div><div class="token-line"><span class="token plain">    /usr/lib/python3.9/selectors.py:403 select</span></div></pre></div><p>恭喜，到这里，你已经成功从 Python 解释器中跟踪到了应用程序中的函数调用。</p><p>对于其他的解释型编程语言，其跟踪过程也是类似的，只是要把跟踪函数换成该语言解释器中处理函数调用的跟踪点。如果你不了解它们底层的实现原理，可以参考 BCC 的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/iovisor/bcc/blob/b82de2db5eece171decc5205f8a426cf8790d19e/tools/lib/ucalls.py#L60-L109">ucalls<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://github.com/iovisor/bcc/blob/master/tools/lib/uflow.py">uflow<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，开发针对它们的跟踪程序。</p><p>刚才我们使用的是 bpftrace，如果你想使用 BCC 和 libbpf 来开发更复杂的跟踪功能也是没问题的。比如，还是以 BCC 为例，它的跟踪过程与编译型语言相比，主要有两个不同点，下面我们来具体看看。</p><p>第一，在 eBPF 程序部分，USDT 跟踪点需要调用 <code>bpf_usdt_readarg()</code> 函数，来读取函数参数（对于指针类数据，还需调用 <code>bpf_probe_read_user()</code> 读取指针指向的内容），代码如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 头文件引用和数据结构定义...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int print_functions(struct pt_regs *ctx)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        uint64_t argptr;</span></div><div class="token-line"><span class="token plain">        struct data_t data = { };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 参数1是文件名</span></div><div class="token-line"><span class="token plain">        bpf_usdt_readarg(1, ctx, &amp;argptr);</span></div><div class="token-line"><span class="token plain">        bpf_probe_read_user(&amp;data.filename, sizeof(data.filename),</span></div><div class="token-line"><span class="token plain">                    (void *)argptr);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 参数2是函数名</span></div><div class="token-line"><span class="token plain">        bpf_usdt_readarg(2, ctx, &amp;argptr);</span></div><div class="token-line"><span class="token plain">        bpf_probe_read_user(&amp;data.funcname, sizeof(data.funcname),</span></div><div class="token-line"><span class="token plain">                    (void *)argptr);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      // 参数3是行号</span></div><div class="token-line"><span class="token plain">      bpf_usdt_readarg(3, ctx, &amp;data.lineno);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 最后提交性能事件</span></div><div class="token-line"><span class="token plain">        events.perf_submit(ctx, &amp;data, sizeof(data));</span></div><div class="token-line"><span class="token plain">        return 0;</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>第二，在 Python 前端程序中，挂载跟踪点时需要换成 USDT 跟踪点，即：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">from bcc import BPF, USDT</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    u = USDT(pid=pid)</span></div><div class="token-line"><span class="token plain">    u.enable_probe(probe=&quot;function__entry&quot;, fn_name=&quot;print_functions&quot;)</span></div><div class="token-line"><span class="token plain">    b = BPF(src_file=&quot;&lt;ebpf-program&gt;.c&quot;, usdt_contexts=[u])</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 其他处理逻辑</span></div></pre></div><p>除了这两个不同点，其他的逻辑都是类似的。那么，参考上述的编译型语言跟踪程序，你能在这两个不同点的基础上，写出完整的 BCC 跟踪程序吗？这里你可以先想一想，这也是今天留给你的思考题。欢迎你在课后跟我分享你的思路和实现方法。</p><h2 id="跟踪即时编译型语言应用程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#跟踪即时编译型语言应用程序"><span class="icon icon-link"></span></a><strong>跟踪即时编译型语言应用程序</strong></h2><p>除了上面两类编程语言，还有一种是 Java、.Net 等即时编译型语言。对于这类编程语言开发的应用程序，应用源代码会先编译为字节码，再由即时编译器（JIT）编译为机器码执行。以 Java 为例，Java 虚拟机（JVM）除了会执行常规的 JIT 即时编译之外，还会在执行过程中对运行流程进行剖析和优化，因而也加大了跟踪的难度。</p><p>同解释型编程语言类似，uprobe 和 USDT 跟踪只能用在即时编译器上，从即时编译器的跟踪点参数里面获取最终应用程序的函数信息。由于 USDT 跟踪点比 uprobe 更为稳定，如果编程语言提供了 USDT 跟踪功能，我推荐打开 USDT 跟踪（比如 Java 需要打开 <code>--enable-dtrace</code> 编译选项），再利用 USDT 而不是 uprobe 去跟踪应用的执行过程。</p><p>要找出即时编译器的跟踪点同应用程序运行之间的关系，就需要你对编程语言的底层运行原理非常熟悉，这也是跟踪即时编译型语言应用程序最难的一步。不过这一步梳理清楚之后，具体的跟踪步骤与解释型编程语言应用程序是类似的。</p><p>如果你需要跟踪这类编程语言开发的应用，可以参考 BCC 提供的一系列<a target="_blank" rel="noopener noreferrer" href="https://github.com/iovisor/bcc/tree/master/tools/lib">用户态跟踪库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这里面已经包含了常见的几种编程语言的适配，具体的跟踪步骤我在这里就不展开了。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#小结"><span class="icon icon-link"></span></a><strong>小结</strong></h2><p>今天，我带你一起梳理了应用进程的跟踪方法，并以 Bash 和 Python 这两种编程语言为例，带你开发了它们的 uprobe 和 USDT 等不同类型的跟踪程序。</p><p>在跟踪应用进程之前，你需要先获取这个进程所对应的二进制文件的跟踪点，以及这些跟踪点同应用程序函数的对应关系。<strong>这个对应关系依赖于编程语言的类型</strong>：编译型语言开发的程序中直接包含了应用程序的符号信息，因而可以直接拿来跟踪；而解释型语言和即时编译型语言的二进制文件，只包含了解释器或即时编译器的符号信息，所以应用程序的运行状态还需要从解释器或即时编译器跟踪的参数中去获取。</p><p>在这一讲结束之前，我还想提醒你：<strong>用户进程的跟踪</strong>**，****本质上是通过断点去执行 uprobe 处理程序。**虽然内核社区已经对 BPF 做了很多的性能调优，跟踪用户态函数（特别是锁争用、内存分配之类的高频函数）还是有可能带来很大的性能开销。因此，我们在使用 uprobe 时，应该尽量避免跟踪高频函数。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>在跟踪 Python 语言程序的 BCC 案例中，我列出了它在使用 USDT 跟踪时，相对于编译型语言的两个不同点：</p><ul><li>eBPF 程序中需要调用 <code>bpf_usdt_readarg()</code> 来读取参数；</li><li>Python 前端中需要挂载 USDT 跟踪点。</li></ul><p>根据这些提示，以及上面的编译型语言 BCC 跟踪程序，你能试着写出完整的 BCC 跟踪程序吗？欢迎在评论区和我分享你的思路和解决方法。</p><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/ebpf核心技术与实战/04.实战进阶篇/03.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:48:00</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect3/umi.0a9ffe80.js"></script>
  </body>
</html>
