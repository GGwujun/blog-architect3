<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect3/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect3";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>12｜高性能网络实战（上）：如何开发一个负载均衡器？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/ebpf核心技术与实战/04.实战进阶篇/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词/01"><span>开篇词 | 想要洞悉系统底层的黑盒？先掌握 eBPF！</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇">02.学习准备篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/01"><span>01｜技术概览：eBPF 的发展历程及工作原理</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/02"><span>02 | 先利其器：如何高效学习 eBPF？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇">03.基础入门篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/01"><span>03 | 初窥门径：开发并运行你的第一个 eBPF 程序</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02"><span>04 | 运行原理：eBPF 是一个新的虚拟机吗？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/03"><span>05 | 编程接口：eBPF 程序是怎么跟内核进行交互的？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/04"><span>06 | 事件触发：各类 eBPF 程序的触发机制及其应用场景</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇">04.实战进阶篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/01"><span>07 | 内核跟踪（上）：如何查询内核中的跟踪点？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/02"><span>08｜内核跟踪（下）：开发内核跟踪程序的进阶方法</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03"><span>09 | 用户态跟踪：如何使用 eBPF 排查应用程序？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/04"><span>10 | 网络跟踪：如何使用 eBPF 排查网络问题？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/05"><span>11 | 容器安全：如何使用 eBPF 增强容器安全？</span></a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06"><span>12｜高性能网络实战（上）：如何开发一个负载均衡器？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07"><span>13｜高性能网络实战（下）：如何完善负载均衡器？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结">05.阶段总结</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/01"><span>阶段总结｜实用 eBPF 工具及最新开源项目总结</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/02"><span>未来可期｜邀你与 eBPF 共赴一场技术革新之约</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇">06.技术雷达篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇/01"><span>难点解析｜eBPF 开发环境搭建及内核编译详解</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇/01"><span>加餐｜李程远：谈谈 eBPF 在云原生中的纵与横</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/summary">ebpf核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Nginx 负载均衡器" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#nginx-负载均衡器"><span>Nginx 负载均衡器</span></a></li><li title="如何使用 eBPF 优化负载均衡性能？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#如何使用-ebpf-优化负载均衡性能"><span>如何使用 eBPF 优化负载均衡性能？</span></a></li><li title="使用套接字 eBPF 程序优化网络性能" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#使用套接字-ebpf-程序优化网络性能"><span>使用套接字 eBPF 程序优化网络性能</span></a></li><li title="创建套接字映射" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#创建套接字映射"><span>创建套接字映射</span></a></li><li title="更新套接字映射" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#更新套接字映射"><span>更新套接字映射</span></a></li><li title="套接字转发" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#套接字转发"><span>套接字转发</span></a></li><li title="加载 eBPF 程序" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#加载-ebpf-程序"><span>加载 eBPF 程序</span></a></li><li title="性能测试" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#性能测试"><span>性能测试</span></a></li><li title="案例清理" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#案例清理"><span>案例清理</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="12高性能网络实战上如何开发一个负载均衡器"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#12高性能网络实战上如何开发一个负载均衡器"><span class="icon icon-link"></span></a>12｜高性能网络实战（上）：如何开发一个负载均衡器？</h1><p>你好，我是倪朋飞。</p><p>上一讲，我带你一起梳理了 eBPF 的安全能力，并教你使用 eBPF 分析和阻止了容器进程的安全问题。在开篇词中我就提到，eBPF 的主要应用场景涵盖了故障诊断、性能监控、安全控制以及网络优化等。从 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484207">07 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 进入实战进阶篇开始，我已经为你介绍了应用于前三个场景中的内核跟踪、用户态跟踪、网络跟踪以及安全控制等。那么，对于最后一个场景，网络性能优化，eBPF 是如何发挥作用的呢？</p><p>今天，我就以最常用的负载均衡器为例，带你一起来看看如何借助 eBPF 来优化网络的性能。</p><h2 id="nginx-负载均衡器"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#nginx-负载均衡器"><span class="icon icon-link"></span></a>Nginx 负载均衡器</h2><p>既然要优化负载均衡器的网络性能，那么首先就需要有一个优化的目标，即初始版的负载均衡器。在今天的案例中，我们使用最常用的反向代理和 Web 服务器 Nginx 作为初始版的负载均衡器，同时也使用自定义的 Nginx 作为后端的 Web 服务器。</p><p>为了方便环境的重现，负载均衡器、 Web 服务器以及客户端都运行在容器中，它们的 IP 和 MAC 等基本信息如下图所示：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimagee915e923026f577f7b991be2610734f9e415.5590f82b.jpg" alt="图片"/></p><p>参考 Nginx 官方文档中 <a target="_blank" rel="noopener noreferrer" href="https://docs.nginx.com/nginx/admin-guide/load-balancer/http-load-balancer/">HTTP 负载均衡<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的配置方法，你可以通过以下几步来搭建上述的案例环境。</p><p>1）执行下面的命令，创建上图中的4个容器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># Webserver (响应是hostname，如 http1 或 http2)</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=http1 --hostname=http1 feisky/webserver</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=http2 --hostname=http2 feisky/webserver</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # Client</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=client alpine</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # Nginx</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=nginx nginx</span></div></pre></div><p>注意，这儿启动的 Nginx 容器使用的还是官方镜像，还需要额外的步骤更新它的负载均衡配置。</p><blockquote><p>小提示：在默认安装的 Docker 环境中，假如你没有运行其他容器，运行上述命令后得到的 IP 地址跟图中是相同的。</p></blockquote><p>2）执行下面的命令，查询两个 Web 服务器的 IP 地址：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">IP1=$(docker inspect http1 -f &#x27;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27;)</span></div><div class="token-line"><span class="token plain">    IP2=$(docker inspect http2 -f &#x27;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27;)</span></div><div class="token-line"><span class="token plain">    echo &quot;Webserver1&#x27;s IP: $IP1&quot;</span></div><div class="token-line"><span class="token plain">    echo &quot;Webserver2&#x27;s IP: $IP2&quot;</span></div></pre></div><p>命令执行后，你将会看到如下的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Webserver1&#x27;s IP: 172.17.0.2</span></div><div class="token-line"><span class="token plain">    Webserver2&#x27;s IP: 172.17.0.3</span></div></pre></div><p>3）执行下面的命令，生成并更新 Nginx 配置：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 生成nginx.conf文件</span></div><div class="token-line"><span class="token plain">    cat&gt;nginx.conf &lt;&lt;EOF</span></div><div class="token-line"><span class="token plain">    user  nginx;</span></div><div class="token-line"><span class="token plain">    worker_processes  auto;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    error_log  /var/log/nginx/error.log notice;</span></div><div class="token-line"><span class="token plain">    pid        /var/run/nginx.pid;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    events {</span></div><div class="token-line"><span class="token plain">        worker_connections  1024;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    http {</span></div><div class="token-line"><span class="token plain">       include       /etc/nginx/mime.types;</span></div><div class="token-line"><span class="token plain">       default_type  application/octet-stream;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        upstream webservers {</span></div><div class="token-line"><span class="token plain">            server $IP1;</span></div><div class="token-line"><span class="token plain">            server $IP2;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        server {</span></div><div class="token-line"><span class="token plain">            listen 80;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">            location / {</span></div><div class="token-line"><span class="token plain">                proxy_pass http://webservers;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    EOF</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 更新Nginx配置</span></div><div class="token-line"><span class="token plain">    docker cp nginx.conf nginx:/etc/nginx/nginx.conf</span></div><div class="token-line"><span class="token plain">    docker exec nginx nginx -s reload</span></div></pre></div><p>配置完成后，再执行下面的命令，验证负载均衡器是不是生效了（<code>/ #</code> 表示在容器终端中执行命令）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 查询Nginx容器IP（输出为172.17.0.5）</span></div><div class="token-line"><span class="token plain">    docker inspect nginx -f &#x27;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 进入client容器终端，安装curl之后访问Nginx</span></div><div class="token-line"><span class="token plain">    docker exec -it client sh</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # (以下命令运行在client容器中)</span></div><div class="token-line"><span class="token plain">    / # apk add curl wrk --update</span></div><div class="token-line"><span class="token plain">    / # curl &quot;http://172.17.0.5&quot;</span></div></pre></div><p>如果一切正常，多次执行 curl 命令后，你会看到如下的输出，即通过 Nginx 成功获得了两个 Web 服务器的输出，说明负载均衡器配置成功了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/ # curl &quot;http://172.17.0.5&quot;</span></div><div class="token-line"><span class="token plain">    Hostname: http1</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    / # curl &quot;http://172.17.0.5&quot;</span></div><div class="token-line"><span class="token plain">    Hostname: http2</span></div></pre></div><p>负载均衡器配置成功后，它的性能怎么样呢？进入 client 容器终端中，执行下面的命令，就可以使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/wg/wrk">wrk<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 给它做个性能测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/ # apk add wrk --update</span></div><div class="token-line"><span class="token plain">    / # wrk -c100 &quot;http://172.17.0.5&quot;</span></div></pre></div><p>稍等一会，你可以看到如下的性能测试报告：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Running 10s test @ http://172.17.0.5</span></div><div class="token-line"><span class="token plain">      2 threads and 100 connections</span></div><div class="token-line"><span class="token plain">      Thread Stats   Avg      Stdev     Max   +/- Stdev</span></div><div class="token-line"><span class="token plain">        Latency     7.53ms    4.96ms  39.33ms   70.78%</span></div><div class="token-line"><span class="token plain">        Req/Sec     6.96k   514.59     8.88k    74.00%</span></div><div class="token-line"><span class="token plain">      138711 requests in 10.05s, 21.83MB read</span></div><div class="token-line"><span class="token plain">    Requests/sec:  13798.11</span></div><div class="token-line"><span class="token plain">    Transfer/sec:      2.17MB</span></div></pre></div><p>从报告中你可以发现，默认情况下，总的平均每秒请求数是 13798，而每个线程的平均请求数和请求延迟是 6.96k 和 7.53 毫秒（在你的环境下可能看到不同数值，具体的性能指标取决于运行环境和配置）。你可以记录一下这些数值，以便后面跟 eBPF 进行比较。</p><h2 id="如何使用-ebpf-优化负载均衡性能"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#如何使用-ebpf-优化负载均衡性能"><span class="icon icon-link"></span></a>如何使用 eBPF 优化负载均衡性能？</h2><p>有了待优化的 eBPF 负载均衡器之后，接下来就是使用 eBPF 进行优化了。在开始接下来的内容之前，你可以先回顾一下我们之前课程的内容，思考有哪些可能的方案可以用在负载均衡的性能优化场景中。</p><p>在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/483364">06 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中我曾提到过，每个 eBPF 程序都属于特定的类型，不同类型 eBPF 程序的触发事件是不同的。既然是网络的性能优化，自然应该去考虑网络类的 eBPF 程序。根据触发事件的不同，网络类 eBPF 程序可以分为 XDP程序、TC程序、套接字程序以及 cgroup 程序。这几类程序的触发事件和常用场景分别为：</p><ul><li>XDP 程序在网络驱动程序刚刚收到数据包的时候触发执行，支持卸载到网卡硬件，常用于防火墙和四层负载均衡；</li><li>TC 程序在网卡队列接收或发送的时候触发执行，运行在内核协议栈中，常用于流量控制；</li><li>套接字程序在套接字发生创建、修改、收发数据等变化的时候触发执行，运行在内核协议栈中，常用于过滤、观测或重定向套接字网络包。其中，BPF_PROG_TYPE_SOCK_OPS、BPF_PROG_TYPE_SK_SKB、BPF_PROG_TYPE_SK_MSG 等都可以用于套接字重定向；</li><li>cgroup 程序在 cgroup 内所有进程的套接字创建、修改选项、连接等情况下触发执行，常用于过滤和控制 cgroup 内多个进程的套接字。</li></ul><p>根据这些触发事件，你可以发现这几类网络程序都有可能用在网络性能优化上。其中，由于支持卸载到硬件，XDP 的性能应该是最好的；而由于直接作用在套接字上，套接字程序和 cgroup 程序是最接近应用的。</p><p>既然有多种不同的性能优化方式，我就以套接字和 XDP 这两种方式为例，带你优化负载均衡的性能。由于内容比较多，接下来我们先看套接字 eBPF 程序的优化方法，而 XDP 方法我会在下一讲中为你介绍。</p><h2 id="使用套接字-ebpf-程序优化网络性能"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#使用套接字-ebpf-程序优化网络性能"><span class="icon icon-link"></span></a>使用套接字 eBPF 程序优化网络性能</h2><p>根据原理的不同，套接字 eBPF 程序又分为很多不同的类型。其中，BPF_PROG_TYPE_SOCK_OPS、BPF_PROG_TYPE_SK_SKB、BPF_PROG_TYPE_SK_MSG 等类型的 eBPF 程序可以与套接字映射（如 BPF_MAP_TYPE_SOCKMAP 或 BPF_MAP_TYPE_SOCKHASH）配合，实现套接字的转发。</p><p>套接字 eBPF 程序工作在内核空间中，无需把网络数据发送到用户空间就能完成转发。因此，我们可以先猜测，它应该是可以提升网络转发的性能（当然，具体能不能提升，还需要接下来的测试验证）。</p><p>具体来说，使用套接字映射转发网络包需要以下几个步骤：</p><ol><li>创建套接字映射；</li><li>在 BPF_PROG_TYPE_SOCK_OPS 类型的 eBPF 程序中，将新创建的套接字存入套接字映射中；</li><li>在流解析类的 eBPF 程序（如 BPF_PROG_TYPE_SK_SKB 或 BPF_PROG_TYPE_SK_MSG ）中，从套接字映射中提取套接字信息，并调用 BPF 辅助函数转发网络包；</li><li>加载并挂载 eBPF 程序到套接字事件。</li></ol><p>接下来，我们一起看看具体每一步该如何操作。</p><h3 id="创建套接字映射"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#创建套接字映射"><span class="icon icon-link"></span></a>创建套接字映射</h3><p>首先，第一步是创建一个套接字类型的映射。以 BPF_MAP_TYPE_SOCKHASH 类型的套接字映射为例，它的值总是套接字文件描述符，而键则需要我们去定义。比如，可以定义一个包含 IP 协议五元组的结构体，作为套接字映射的键类型：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct sock_key</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        __u32 sip;    //源IP</span></div><div class="token-line"><span class="token plain">        __u32 dip;    //目的IP</span></div><div class="token-line"><span class="token plain">        __u32 sport;  //源端口</span></div><div class="token-line"><span class="token plain">        __u32 dport;  //目的端口</span></div><div class="token-line"><span class="token plain">        __u32 family; //协议</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>有了键类型之后，就可以使用 <code>SEC</code> 关键字来定义套接字映射了，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;linux/bpf.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct bpf_map_def SEC(&quot;maps&quot;) sock_ops_map = {</span></div><div class="token-line"><span class="token plain">        .type = BPF_MAP_TYPE_SOCKHASH,</span></div><div class="token-line"><span class="token plain">        .key_size = sizeof(struct sock_key),</span></div><div class="token-line"><span class="token plain">        .value_size = sizeof(int),</span></div><div class="token-line"><span class="token plain">        .max_entries = 65535,</span></div><div class="token-line"><span class="token plain">        .map_flags = 0,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>为了方便后续在 eBPF 程序中引用这两个数据结构，你可以把它们保存到一个头文件 <code>sockops.h</code> 中（你还可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/sockops/sockops.h">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中找到完整的代码）。</p><h3 id="更新套接字映射"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#更新套接字映射"><span class="icon icon-link"></span></a>更新套接字映射</h3><p>套接字映射准备好之后，第二步就是在 BPF_PROG_TYPE_SOCK_OPS 类型的 eBPF 程序中跟踪套接字事件，并把套接字信息保存到 SOCKHASH 映射中。</p><p>参考内核中 BPF_PROG_TYPE_SOCK_OPS 程序类型的<a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h#L29">定义格式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它的参数格式为 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5506">struct bpf_sock_ops<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BPF_PROG_TYPE(BPF_PROG_TYPE_SOCK_OPS, sock_ops,</span></div><div class="token-line"><span class="token plain">        struct bpf_sock_ops, struct bpf_sock_ops_kern)</span></div></pre></div><p>因此，你就可以使用如下的格式来定义这个 eBPF 程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SEC(&quot;sockops&quot;)</span></div><div class="token-line"><span class="token plain">    int bpf_sockmap(struct bpf_sock_ops *skops)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      // TODO: 添加套接字映射更新操作</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在添加具体的套接字映射更新逻辑之前，还需要你先从 <code>struct bpf_sock_ops</code>中获取作为键类型的五元组。参考内核中 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5506">struct bpf_sock_ops<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的定义，如下的几个字段刚好可以满足我们的需要：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct bpf_sock_ops {</span></div><div class="token-line"><span class="token plain">      __u32 family;</span></div><div class="token-line"><span class="token plain">      __u32 remote_ip4;	/* Stored in network byte order */</span></div><div class="token-line"><span class="token plain">      __u32 local_ip4;	/* Stored in network byte order */</span></div><div class="token-line"><span class="token plain">      __u32 remote_port;/* Stored in network byte order */</span></div><div class="token-line"><span class="token plain">      __u32 local_port;	/* stored in host byte order */</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>因此，你就可以直接使用它们来定义映射中所需要的键。下面就是 <code>sock_key</code> 的定义方法，注意这里把 <code>local_port</code> 转换为了同其他字段一样的网络字节序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct sock_key key = {</span></div><div class="token-line"><span class="token plain">      .dip = skops-&gt;remote_ip4,</span></div><div class="token-line"><span class="token plain">      .sip = skops-&gt;local_ip4,</span></div><div class="token-line"><span class="token plain">      .sport = bpf_htonl(skops-&gt;local_port),</span></div><div class="token-line"><span class="token plain">      .dport = skops-&gt;remote_port,</span></div><div class="token-line"><span class="token plain">      .family = skops-&gt;family,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>有了键之后，还不能立刻就去更新套接字映射。这是因为 BPF_PROG_TYPE_SOCK_OPS 程序跟踪了所有类型的套接字操作，而我们只需要把新创建的套接字更新到映射中。</p><p><code>struct bpf_sock_ops</code> 中包含的 <code>op</code> 字段可用于判断套接字操作类型，其定义格式可以参考<a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5638">这里的内核头文件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。内核头文件中已经为每种操作的具体含义加了详细的注释，对于新创建的连接，我们就可以使用以下两个状态（即主动连接和被动连接）作为判断条件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/* skip if it is not established op */</span></div><div class="token-line"><span class="token plain">    if (skops-&gt;op != BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB &amp;&amp; skops-&gt;op != BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB) {</span></div><div class="token-line"><span class="token plain">      return BPF_OK;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>到这里，说明套接字已经属于新创建的连接了，所以接下来就是调用 BPF 辅助函数去更新套接字映射，如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bpf_sock_hash_update(skops, &amp;sock_ops_map, &amp;key, BPF_NOEXIST);</span></div></pre></div><p>其中，<code>BPF_NOEXIST</code> 表示键不存在的时候才添加新元素。</p><p>再加上必要的头文件，完整的 eBPF 程序如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;linux/bpf.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;bpf/bpf_endian.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;bpf/bpf_helpers.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/socket.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &quot;sockops.h&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    SEC(&quot;sockops&quot;)</span></div><div class="token-line"><span class="token plain">    int bpf_sockmap(struct bpf_sock_ops *skops)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        /* skip if the packet is not ipv4 */</span></div><div class="token-line"><span class="token plain">        if (skops-&gt;family != AF_INET)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            return BPF_OK;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        /* skip if it is not established op */</span></div><div class="token-line"><span class="token plain">        if (skops-&gt;op != BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB &amp;&amp; skops-&gt;op != BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB) {</span></div><div class="token-line"><span class="token plain">            return BPF_OK;</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        struct sock_key key = {</span></div><div class="token-line"><span class="token plain">            .dip = skops-&gt;remote_ip4,</span></div><div class="token-line"><span class="token plain">            .sip = skops-&gt;local_ip4,</span></div><div class="token-line"><span class="token plain">            /* convert to network byte order */</span></div><div class="token-line"><span class="token plain">            .sport = (bpf_htonl(skops-&gt;local_port)),</span></div><div class="token-line"><span class="token plain">            .dport = skops-&gt;remote_port,</span></div><div class="token-line"><span class="token plain">            .family = skops-&gt;family,</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        bpf_sock_hash_update(skops, &amp;sock_ops_map, &amp;key, BPF_NOEXIST);</span></div><div class="token-line"><span class="token plain">        return BPF_OK;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;;</span></div></pre></div><p>把上述代码保存到 <code>sockops.bpf.c</code> 文件中（你还可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/sockops/sockops.bpf.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中找到完整的代码），然后执行下面的命令，将其编译为 BPF 字节码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I/usr/include/x86_64-linux-gnu -I. -c sockops.bpf.c -o sockops.bpf.o</span></div></pre></div><p>到这里，套接字更新的 eBPF 程序就准备好了，接下来我们来看看如何转发套接字。</p><h3 id="套接字转发"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#套接字转发"><span class="icon icon-link"></span></a>套接字转发</h3><p>第三步的套接字转发可以使用 BPF_PROG_TYPE_SK_MSG 类型的 eBPF 程序，捕获套接字中的发送数据包，并根据上述的套接字映射进行转发。根据内核头文件中的<a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h#L33">定义格式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它的参数格式为 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5328">struct sk_msg_md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。<code>struct sk_msg_md</code> 的定义格式如下所示，也已经包含了套接字映射所需的五元组信息：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct sk_msg_md {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      __u32 family;</span></div><div class="token-line"><span class="token plain">      __u32 remote_ip4;  /* Stored in network byte order */</span></div><div class="token-line"><span class="token plain">      __u32 local_ip4;   /* Stored in network byte order */</span></div><div class="token-line"><span class="token plain">      __u32 remote_port; /* Stored in network byte order */</span></div><div class="token-line"><span class="token plain">      __u32 local_port;  /* stored in host byte order */</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>了解清楚数据结构的定义格式之后，还需要你注意一点：BPF_PROG_TYPE_SK_MSG 跟 BPF_PROG_TYPE_SOCK_OPS 属于不同的 eBPF 程序。虽然你可以把多个 eBPF 程序放入同一个源码文件，并编译到同一个字节码文件(即 <code>文件名.o</code>）中，但由于它们的加载和挂载格式都是不同的，我推荐你把不同的 eBPF 程序放入不同的文件中，这样管理起来更为方便。</p><p>因此，接下来创建一个新的文件（如 <code>sockredir.bpf.c</code>），用于保存 BPF_PROG_TYPE_SK_MSG 程序。添加如下的代码，就定义了一个名为 <code>bpf_redir</code> 的 eBPF 程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SEC(&quot;sk_msg&quot;)</span></div><div class="token-line"><span class="token plain">    int bpf_redir(struct sk_msg_md *msg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //TODO: 添加套接字转发逻辑</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这个 eBPF 程序中，既然还要访问相同的套接字映射，也就需要从参数 <code>struct sk_msg_md</code> 中提取五元组信息，并存入套接字映射所需要的键 <code>struct sock_key</code> 中。如下所示，我们就定义了一个新的 <code>struct sock_key</code>（注意，这里同样需要把 <code>local_port</code> 转换为网络字节序）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct sock_key key = {</span></div><div class="token-line"><span class="token plain">      .sip = msg-&gt;remote_ip4,</span></div><div class="token-line"><span class="token plain">      .dip = msg-&gt;local_ip4,</span></div><div class="token-line"><span class="token plain">      .dport = bpf_htonl(msg-&gt;local_port),</span></div><div class="token-line"><span class="token plain">      .sport = msg-&gt;remote_port,</span></div><div class="token-line"><span class="token plain">      .family = msg-&gt;family,</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>需要你注意的是，这儿的源 IP 和源端口对应上述 eBPF 程序的目的 IP 和目的端口，也就是说，发送方向刚好是相反的。为什么是相反的呢？来看看下面这张图，原因就很清楚了：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimage3c703c2419d6a357eca924fe6b94ed5b0970.1648e7fe.jpg" alt="图片"/></p><p>图中，灰色箭头是套接字转发之前的网络流向，而绿色箭头则是套接字转发后的网络流向。从这张图中你可以发现：</p><ul><li>在套接字转发之前，即便是在同一台机器的两个容器中，负载均衡器和 Web 服务器的两个套接字通信还是需要通过完整的内核协议栈进行处理的；</li><li>而在套接字转发之后，来自发送端套接字 1 的网络包在套接字层就交给了接收端的套接字 2，从而避免了额外的内核协议栈处理过程。</li></ul><p>由于这两个套接字一个是发送，一个是接收，因而它们的方向是相反的，所以在构造转发套接字的键时，就需要把源和目的交换。</p><p>有了套接字映射所需要的键之后，最后还剩下添加套接字转发逻辑的步骤。参考 BPF 辅助函数文档（你可以执行 <code>man bpf-helpers</code> 查询），<code>bpf_msg_redirect_hash()</code> 正好跟我们的需求完全匹配。为了方便你理解，我把它的使用文档也贴一下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">long bpf_msg_redirect_hash(struct sk_msg_buff *msg, struct bpf_map *map, void *key, u64 flags)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Description</span></div><div class="token-line"><span class="token plain">    This helper is used in programs implementing policies at the socket  level.  If  the</span></div><div class="token-line"><span class="token plain">    message  msg  is allowed to pass (i.e. if the verdict eBPF program returns SK_PASS),</span></div><div class="token-line"><span class="token plain">    redirect it to the socket referenced by map (of  type  BPF_MAP_TYPE_SOCKHASH)  using</span></div><div class="token-line"><span class="token plain">    hash  key.  Both  ingress  and  egress  interfaces  can be used for redirection. The</span></div><div class="token-line"><span class="token plain">    BPF_F_INGRESS value in flags is used to make the distinction (ingress  path  is  se‐</span></div><div class="token-line"><span class="token plain">    lected  if  the  flag is present, egress path otherwise). This is the only flag sup‐</span></div><div class="token-line"><span class="token plain">    ported for now.</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    Return SK_PASS on success, or SK_DROP on error.</span></div></pre></div><p>概括来说，<code>bpf_msg_redirect_hash()</code> 的作用就是把当前套接字转发给套接字映射中的套接字。而参数 <code>key</code> 用于从套接字映射中查询待转发的套接字，<code>flags</code> 用于区分入口或出口路径。</p><p>根据每个参数的具体格式，你就可以通过下面的方式进行套接字转发。注意，对于负载均衡的场景来说，只需要对入口路径进行处理，因而这儿设置了 <code>BPF_F_INGRESS</code>。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bpf_msg_redirect_hash(msg, &amp;sock_ops_map, &amp;key, BPF_F_INGRESS);</span></div></pre></div><p>再加上必要的头文件之后，完整的 eBPF 程序如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;linux/bpf.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;bpf/bpf_endian.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;bpf/bpf_helpers.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;sys/socket.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &quot;sockops.h&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    SEC(&quot;sk_msg&quot;)</span></div><div class="token-line"><span class="token plain">    int bpf_redir(struct sk_msg_md *msg)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        struct sock_key key = {</span></div><div class="token-line"><span class="token plain">            .sip = msg-&gt;remote_ip4,</span></div><div class="token-line"><span class="token plain">            .dip = msg-&gt;local_ip4,</span></div><div class="token-line"><span class="token plain">            .dport = bpf_htonl(msg-&gt;local_port),</span></div><div class="token-line"><span class="token plain">            .sport = msg-&gt;remote_port,</span></div><div class="token-line"><span class="token plain">            .family = msg-&gt;family,</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        bpf_msg_redirect_hash(msg, &amp;sock_ops_map, &amp;key, BPF_F_INGRESS);</span></div><div class="token-line"><span class="token plain">        return SK_PASS;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    char LICENSE[] SEC(&quot;license&quot;) = &quot;Dual BSD/GPL&quot;;</span></div></pre></div><p>把上述代码保存到文件 <code>sockredir.bpf.c</code> 中（你还可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/sockops/sockredir.bpf.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中找到完整的代码），然后执行下面的命令，将其编译为 BPF 字节码：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I/usr/include/x86_64-linux-gnu -I. -c sockredir.bpf.c -o sockredir.bpf.o</span></div></pre></div><h3 id="加载-ebpf-程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#加载-ebpf-程序"><span class="icon icon-link"></span></a>加载 eBPF 程序</h3><p>得到套接字映射更新和转发这两个 BPF 字节码之后，还需要把它们加载到内核之中，再挂载到特定的内核事件之后才会生效。在之前的案例中，我介绍的方法是利用 BCC、libbpf 等提供的库函数。今天，我再为你介绍另外一种方法，即通过命令行工具 bpftool 加载和挂载 eBPF 程序。</p><p>首先，对于 sockops 程序 <code>sockops.bpf.o</code> 来说，你可以执行下面的命令，将其加载到内核中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftool prog load sockops.bpf.o /sys/fs/bpf/sockops type sockops pinmaps /sys/fs/bpf</span></div></pre></div><p>这条命令将 <code>sockops.bpf.o</code> 中的 eBPF 程序和映射加载到内核中，并固定到 BPF 文件系统中。固定到 BPF 文件系统的好处是，即便 bpftool 命令已经执行结束，eBPF 程序还会继续在内核中运行，并且 eBPF 映射也会继续存在内核内存中。</p><p>加载成功后，你还可以执行 <code>bpftool prog show</code> 和 <code>bpftool map show</code> 命令确认它们的加载结果。执行成功后，你会看到类似下面的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ sudo bpftool prog show name bpf_sockmap</span></div><div class="token-line"><span class="token plain">    1062: sock_ops  name bpf_sockmap  tag e37ef726a3a85a2e  gpl</span></div><div class="token-line"><span class="token plain">    	loaded_at 2022-02-04T13:07:28+0000  uid 0</span></div><div class="token-line"><span class="token plain">    	xlated 256B  jited 140B  memlock 4096B  map_ids 90</span></div><div class="token-line"><span class="token plain">    	btf_id 234</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    $ sudo bpftool map show name sock_ops_map</span></div><div class="token-line"><span class="token plain">    90: sockhash  name sock_ops_map  flags 0x0</span></div><div class="token-line"><span class="token plain">    	key 20B  value 4B  max_entries 65535  memlock 1572864B</span></div></pre></div><p>BPF 字节码加载成功之后，其中的 eBPF 程序还不会自动运行，因为这时候它还没有与内核事件挂载。</p><p>对 sockops 程序来说，它支持挂载到 cgroups，从而对 cgroups 所拥有的所有进程生效，这跟我们案例的容器场景也是匹配的。</p><p>虽然 Docker 支持把新容器挂载到 cgroups 子系统中，但在案例开始的时候，我们并没有指定 cgroups 子系统。此时，Docker 会自动把所有容器都添加到系统 cgroups 子系统中。所以，对 sockops 程序来说，就可以把它挂载到系统 cgroups 中，从而对包括容器应用在内的所有进程生效。</p><p>你可以执行下面的 <code>mount</code> 命令，查询当前系统的 cgroups 的挂载路径：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">$ mount | grep cgroup</span></div><div class="token-line"><span class="token plain">    cgroup2 on /sys/fs/cgroup type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot)</span></div></pre></div><p>通常情况下，主流的发行版都会把 cgroups 挂载到 <code>/sys/fs/cgroup</code> 路径下。接着，再执行下面的 <code>bpftool cgroup attach</code> 命令，把 sockops 程序挂载到 cgroups 路径中：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftool cgroup attach /sys/fs/cgroup/ sock_ops pinned /sys/fs/bpf/sockops</span></div></pre></div><p>到这里，sockops 程序的加载和挂载就完成了。</p><p>接下来，再执行下面的命令，加载并挂载 sk_msg 程序 <code>sockredir.bpf.o</code>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftool prog load sockredir.bpf.o /sys/fs/bpf/sockredir type sk_msg map name sock_ops_map pinned /sys/fs/bpf/sock_ops_map</span></div><div class="token-line"><span class="token plain">    sudo bpftool prog attach pinned /sys/fs/bpf/sockredir msg_verdict pinned /sys/fs/bpf/sock_ops_map</span></div></pre></div><p>从这两条命令中你可以看到，sk_msg 程序的加载和挂载过程跟 sockops 程序是类似的，区别只在于它们的程序类型和挂载类型不同：</p><ul><li>sockops 程序的类型是 <code>sock_ops</code>，sk_msg 程序的类型是 <code>sk_msg</code>；</li><li>sockops 程序的挂载类型是 <code>cgroup</code> （对应 <code>bpftool cgroup attach</code> 命令），sk_msg 程序的挂载类型是 <code>msg_verdict</code>（对应 <code>bpftool prog attach</code> 命令）。</li></ul><p>由于 sk_msg 程序需要访问 sockops 程序创建的套接字映射，所以上述命令通过 BPF 文件系统路径 <code>/sys/fs/bpf/sock_ops_map</code> 对套接字映射进行了绑定。</p><p>到这里，两个 eBPF 程序的加载和挂载就都完成了。</p><p>那么，它们是不是真的可以提升网络转发的性能呢？回想一下 Nginx 负载均衡的测试步骤，我们使用相同的方法再做个性能测试，就可以知道了。</p><h3 id="性能测试"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#性能测试"><span class="icon icon-link"></span></a>性能测试</h3><p>执行下面的命令进入 client 容器终端，并在容器终端中执行 <code>wrk</code> 命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">docker exec -it client sh</span></div><div class="token-line"><span class="token plain">    / # wrk -c100 &quot;http://172.17.0.5&quot;</span></div></pre></div><p>稍等一会，你会看到如下的输出（在你的环境下可能看到不同数值，具体的性能指标取决于运行环境和配置）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Running 10s test @ http://172.17.0.5</span></div><div class="token-line"><span class="token plain">      2 threads and 100 connections</span></div><div class="token-line"><span class="token plain">      Thread Stats   Avg      Stdev     Max   +/- Stdev</span></div><div class="token-line"><span class="token plain">        Latency     6.88ms    4.71ms  46.08ms   70.77%</span></div><div class="token-line"><span class="token plain">        Req/Sec     7.70k   548.11     9.10k    66.50%</span></div><div class="token-line"><span class="token plain">      153466 requests in 10.03s, 24.15MB read</span></div><div class="token-line"><span class="token plain">    Requests/sec:  15300.71</span></div><div class="token-line"><span class="token plain">    Transfer/sec:      2.41MB</span></div></pre></div><p>你可以看到，新的平均每秒请求数是 15300，相比优化之前的 13798 提升了 10.8%；而每个线程的平均延迟 6.88ms 也比之前的 7.53ms 降低了 8.6%。这说明，eBPF 真的优化了负载均衡器的转发性能，这跟我们一开始的猜想是一致的。</p><h3 id="案例清理"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#案例清理"><span class="icon icon-link"></span></a>案例清理</h3><p>案例的最后，不要忘记清理今天所加载的 eBPF 程序以及容器环境。</p><p>对于 eBPF 程序来说，清理过程需要卸载（detach）和删除（unload）两个步骤。执行下面的命令，就可以卸载和删除 skops 和 sk_msg 这两个程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># cleanup skops prog and sock_ops_map</span></div><div class="token-line"><span class="token plain">    sudo bpftool cgroup detach /sys/fs/cgroup/ sock_ops name bpf_sockmap</span></div><div class="token-line"><span class="token plain">    sudo rm -f /sys/fs/bpf/sockops /sys/fs/bpf/sock_ops_map</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # cleanup sk_msg prog</span></div><div class="token-line"><span class="token plain">    sudo bpftool prog detach pinned /sys/fs/bpf/sockredir msg_verdict pinned /sys/fs/bpf/sock_ops_map</span></div><div class="token-line"><span class="token plain">    sudo rm -f /sys/fs/bpf/sockredir</span></div></pre></div><p>你可能已经注意到了，与 <code>attach</code> 相对应的清理操作为 <code>detach</code>，但 bpftool 并没有一个与 <code>load</code> 相对应的 <code>unload</code> 子命令。这是因为，eBPF 程序和映射都是与 BPF 文件系统绑定的，文件删除后，它们引用计数降为 0 ，就会被系统自动清理了，所以删除过程只需要把 BPF 文件系统中的文件删除即可。</p><p>而对于容器的清理就更容易了，只需要执行下面的 <code>docker rm</code> 命令即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">docker rm -f http1 http2 client nginx</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天，我带你搭建了一个最简单的负载均衡程序，并借助套接字 eBPF 程序对它的性能进行了优化。</p><p>借助 sockops 和 sk_msg 等套接字 eBPF 程序，你可以在内核态中直接将网络包转发给目的应用的套接字，跳过复杂的内核协议栈，从而提升网络转发的性能。</p><p>在需要加载和挂载 eBPF 程序或映射时，除了可以利用 BCC、libbpf 等提供的库函数之外，你还可以使用 bpftool 这个工具来实现。由于 eBPF 程序及相关的工具还在快速进化中，在碰到不确定的疑问时，我推荐你参考跟当前内核版本匹配的内核头文件定义、man 手册等，去查询关于它们的详细文档，而不要单纯依赖于网络搜索。</p><p>当然，对于网络优化来说，除了套接字 eBPF 程序之外，XDP 程序和 TC 程序也是最常用的性能优化方法，我将在下一讲中为你介绍 XDP 程序的详细使用方法。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后的思考题环节，我们来探讨关于排查套接字映射的问题。</p><p>由于今天的案例中没有添加日志，所以要想观察 eBPF 程序的运行状态，只能通过套接字映射，而 <code>bpftool map dump</code> 命令则提供了查看套接字映射内容的功能。</p><p>在终端中执行下面的 <code>nc</code> 命令，新建一个到 Nginx 容器的连接：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">nc 172.17.0.5 80</span></div></pre></div><p>然后打开一个新终端，执行下面的 <code>bpftool map dump</code> 命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftool map dump name sock_ops_map</span></div></pre></div><p>接着，你就会看到类似下面的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">key:</span></div><div class="token-line"><span class="token plain">    ac 11 00 01 ac 11 00 05  00 00 be 12 00 00 00 50</span></div><div class="token-line"><span class="token plain">    02 00 00 00</span></div><div class="token-line"><span class="token plain">    value:</span></div><div class="token-line"><span class="token plain">    No space left on device</span></div><div class="token-line"><span class="token plain">    key:</span></div><div class="token-line"><span class="token plain">    ac 11 00 05 ac 11 00 01  00 00 00 50 00 00 be 12</span></div><div class="token-line"><span class="token plain">    02 00 00 00</span></div><div class="token-line"><span class="token plain">    value:</span></div><div class="token-line"><span class="token plain">    No space left on device</span></div></pre></div><p>由于 value 对应的是套接字文件描述符，bpftool 无法显示它的内容，所以你可以忽略 <code>No space left on device</code> 的错误（实际上这个错误信息是不准确的，新版本中已经修复了错误信息）。</p><p>而对于 key 来说，则是一长串的十六进制数值。这里我想请你思考两个问题：</p><ol><li>这些十六进制数值是什么意思？它们是如何跟 eBPF 程序中定义的 <code>struct sock_key</code> 关联的？</li><li>你可以尝试把这些十六进制数值转换成 <code>struct sock_key</code> 数据结构，并计算出每个属性的值吗？</li></ol><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/ebpf核心技术与实战/04.实战进阶篇/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:48:00</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect3/umi.0a9ffe80.js"></script>
  </body>
</html>
