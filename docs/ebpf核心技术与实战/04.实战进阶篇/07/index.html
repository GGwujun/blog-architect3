<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect3/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect3";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>13｜高性能网络实战（下）：如何完善负载均衡器？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/ebpf核心技术与实战/04.实战进阶篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词/01"><span>开篇词 | 想要洞悉系统底层的黑盒？先掌握 eBPF！</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇">02.学习准备篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/01"><span>01｜技术概览：eBPF 的发展历程及工作原理</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/02"><span>02 | 先利其器：如何高效学习 eBPF？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇">03.基础入门篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/01"><span>03 | 初窥门径：开发并运行你的第一个 eBPF 程序</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02"><span>04 | 运行原理：eBPF 是一个新的虚拟机吗？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/03"><span>05 | 编程接口：eBPF 程序是怎么跟内核进行交互的？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/04"><span>06 | 事件触发：各类 eBPF 程序的触发机制及其应用场景</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇">04.实战进阶篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/01"><span>07 | 内核跟踪（上）：如何查询内核中的跟踪点？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/02"><span>08｜内核跟踪（下）：开发内核跟踪程序的进阶方法</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03"><span>09 | 用户态跟踪：如何使用 eBPF 排查应用程序？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/04"><span>10 | 网络跟踪：如何使用 eBPF 排查网络问题？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/05"><span>11 | 容器安全：如何使用 eBPF 增强容器安全？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06"><span>12｜高性能网络实战（上）：如何开发一个负载均衡器？</span></a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07"><span>13｜高性能网络实战（下）：如何完善负载均衡器？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结">05.阶段总结</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/01"><span>阶段总结｜实用 eBPF 工具及最新开源项目总结</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/02"><span>未来可期｜邀你与 eBPF 共赴一场技术革新之约</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇">06.技术雷达篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇/01"><span>难点解析｜eBPF 开发环境搭建及内核编译详解</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇/01"><span>加餐｜李程远：谈谈 eBPF 在云原生中的纵与横</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/summary">ebpf核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="案例准备" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#案例准备"><span>案例准备</span></a></li><li title="如何用 XDP 开发一个负载均衡器？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#如何用-xdp-开发一个负载均衡器"><span>如何用 XDP 开发一个负载均衡器？</span></a></li><li title="开发 XDP eBPF 程序" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#开发-xdp-ebpf-程序"><span>开发 XDP eBPF 程序</span></a></li><li title="编译并生成脚手架头文件" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#编译并生成脚手架头文件"><span>编译并生成脚手架头文件</span></a></li><li title="开发用户态程序" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#开发用户态程序"><span>开发用户态程序</span></a></li><li title="性能测试" data-depth="3"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#性能测试"><span>性能测试</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="13高性能网络实战下如何完善负载均衡器"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#13高性能网络实战下如何完善负载均衡器"><span class="icon icon-link"></span></a>13｜高性能网络实战（下）：如何完善负载均衡器？</h1><p>你好，我是倪朋飞。</p><p>上一讲，我带你使用 sockops 和 sk_msg 等套接字 eBPF 程序，在内核态对套接字进行转发，提升了负载均衡的性能。</p><p>对于网络优化来说，除了套接字 eBPF 程序，XDP 程序和 TC 程序也可以用来优化网络的性能。特别是 XDP 程序，由于它在 Linux 内核协议栈之前就可以处理网络包，在负载均衡、防火墙等需要高性能网络的场景中已经得到大量的应用。</p><p>XDP 程序在内核协议栈初始化之前运行，这也就意味着在 XDP 程序中，你并不能像在 sockops 等程序中那样直接获得套接字的详细信息。使用 XDP 程序加速负载均衡，通常也就意味着需要从头开发一个负载均衡程序。这是不是说 XDP 的使用就特别复杂，需要重新实现内核协议栈的很多逻辑呢？不要担心，<strong>XDP 处理过的数据包还可以正常通过内核协议栈继续处理，所以你只需要在 XDP 程序中实现最核心的网络逻辑就可以了</strong>。</p><p>今天，我就以 XDP 程序为例，带你继续优化和完善负载均衡器的性能。</p><h2 id="案例准备"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#案例准备"><span class="icon icon-link"></span></a>案例准备</h2><p>跟上一讲类似，为了方便环境的重现，负载均衡器、Web 服务器以及客户端都还是运行在容器中，它们的 IP 和 MAC 等基本信息如下图所示：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimagee915e923026f577f7b991be2610734f9e415.5590f82b.jpg" alt="图片"/><br/>执行下面的命令，启动这几个容器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># Webserver</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=http1 --hostname=http1 feisky/webserver</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=http2 --hostname=http2 feisky/webserver</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # Client</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=client alpine</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # LB</span></div><div class="token-line"><span class="token plain">    docker run -itd --name=lb --privileged -v /sys/kernel/debug:/sys/kernel/debug alpine</span></div></pre></div><blockquote><p>小提示：在默认安装的 Docker 环境中，假如你没有运行其他容器，运行上述命令后得到的 IP 地址跟图中是相同的。</p></blockquote><p>注意，我们把作为负载均衡器的 Nginx 换成了基于 alpine 镜像的 SHELL 容器，并且以特权容器的方式运行，以便有足够的权限加载并运行 XDP 程序。</p><p>把 XDP 程序放入容器中，除了容易复现案例环境之外，在开发和调试 XDP 程序的过程中也不会影响主机的网络（否则，错误的 XDP 程序可能导致主机网络中断，进而也会影响远程 SSH 连接）。</p><p>由于负载均衡容器只启动了一个 SHELL 环境，并没有运行真正的负载均衡服务。此时，访问负载均衡器的 TCP 80 端口会直接失败。你可以运行下面的命令到客户端容器中验证（<code>/ #</code> 后的命令表示在容器终端中运行）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">docker exec -it client sh</span></div><div class="token-line"><span class="token plain">    / # apk add curl --update</span></div><div class="token-line"><span class="token plain">    / # curl &quot;http://172.17.0.5&quot;</span></div><div class="token-line"><span class="token plain">    curl: (7) Failed to connect to 172.17.0.5 port 80 after 1 ms: Connection refused</span></div></pre></div><p>案例所需的容器环境启动完毕后，接下来我们再来看看，如何使用 XDP 开发一个负载均衡服务。由于需要把 XDP 字节码放到容器中运行，本着最小依赖的原则，我们将使用 libbpf 作为 XDP 的基础库，这样只需要把编译后的二进制文件放入容器中即可运行。</p><h2 id="如何用-xdp-开发一个负载均衡器"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#如何用-xdp-开发一个负载均衡器"><span class="icon icon-link"></span></a>如何用 XDP 开发一个负载均衡器？</h2><p>还记得我在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484372">08 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中提到过的基于 libbpf 开发 eBPF 程序的基本步骤吗？不记得也没关系，我们再来回顾一下。 libbpf 的使用通常分为以下几步：</p><ol><li>开发 eBPF 程序，并把源文件命名为 <code>&lt;程序名&gt;.bpf.c</code>；</li><li>编译 eBPF 程序为字节码，然后再调用 <code>bpftool gen skeleton</code> 为 eBPF 字节码生成脚手架头文件；</li><li>开发用户态程序，引入生成的脚手架头文件后，加载 eBPF 程序并挂载到相应的内核事件中。</li></ol><p>接下来，我们就按这几个步骤来开发 XDP 负载均衡程序。</p><h3 id="开发-xdp-ebpf-程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#开发-xdp-ebpf-程序"><span class="icon icon-link"></span></a>开发 XDP eBPF 程序</h3><p>第一步是开发一个运行在内核态的 eBPF 程序。参考内核中 BPF_PROG_TYPE_XDP 程序类型的<a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/linux/bpf_types.h#L11">定义格式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它的参数类型为 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5283">struct xdp_md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#define BPF_PROG_TYPE(_id, _name, prog_ctx_type, kern_ctx_type)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    BPF_PROG_TYPE(BPF_PROG_TYPE_XDP, xdp,</span></div><div class="token-line"><span class="token plain">           struct xdp_md, struct xdp_buff)</span></div></pre></div><p>因而，你就可以使用如下的格式来定义这个 XDP 程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SEC(&quot;xdp&quot;)</span></div><div class="token-line"><span class="token plain">    int xdp_proxy(struct xdp_md *ctx)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      // TODO: 添加XDP负载均衡逻辑</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码中，<code>SEC(&quot;xdp&quot;)</code> 表示程序的类型为 XDP 程序。你可以在 libbpf 中 <a target="_blank" rel="noopener noreferrer" href="https://github.com/libbpf/libbpf/blob/master/src/libbpf.c#L8599-L8675">section_defs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>找到所有 eBPF 程序类型对应的段名称格式。</p><p>参考 <code>linux/bpf.h</code> 头文件中 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5283">struct xdp_md<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的定义格式，你可以发现，它比上一讲用到的 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/bpf.h#L5506">struct bpf_sock_ops<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 简单多了，只包含了如下的几个字段：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct xdp_md {</span></div><div class="token-line"><span class="token plain">      __u32 data;</span></div><div class="token-line"><span class="token plain">      __u32 data_end;</span></div><div class="token-line"><span class="token plain">      __u32 data_meta;</span></div><div class="token-line"><span class="token plain">      /* Below access go through struct xdp_rxq_info */</span></div><div class="token-line"><span class="token plain">      __u32 ingress_ifindex; /* rxq-&gt;dev-&gt;ifindex */</span></div><div class="token-line"><span class="token plain">      __u32 rx_queue_index;  /* rxq-&gt;queue_index  */</span></div><div class="token-line"><span class="token plain">      __u32 egress_ifindex;  /* txq-&gt;dev-&gt;ifindex */</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>从 <code>struct xdp_md</code> 的定义中你可以看到，所有的字段都是整型数值，其中前三个表示数据指针信息（包括开始位置、结束位置、元数据位置），而后三个表示关联网卡的信息（包括入口网卡、入口网卡队列以及出口网卡的编号）。</p><p>由于 <code>struct xdp_md</code> 中并不包含 skb 数据结构，在 XDP 程序中，你只能通过 <code>data</code> 和 <code>data_end</code> 这两个指针去访问网络报文数据。而要想利用原始网络数据指针来访问网络数据，就需要你了解 TCP/IP 网络报文的基本格式。</p><p>为了方便你理解，我画了一张图，标记了以太网头、IP 头以及 TCP 头等相对于 <code>struct xdp_md</code> 中数据指针的位置关系：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimageyy91yy7887570f06c1d075eb31701924e791.8f793e00.jpg" alt="图片"/><br/>有了这些对应关系，要访问 TCP/IP 协议某一层的头结构，就可以使用开始指针 <code>data</code> 再加上它之前所有头结构大小的偏移。</p><p>比如，对于以太网头，它的位置跟开始位置 <code>data</code> 是相同的，因而你就可以使用下面的方式，把它转换为指针格式进行访问：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">void *data = (void *)(long)ctx-&gt;data;</span></div><div class="token-line"><span class="token plain">    void *data_end = (void *)(long)ctx-&gt;data_end;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    struct ethhdr *eth = data;</span></div><div class="token-line"><span class="token plain">    if (data + sizeof(struct ethhdr) &gt; data_end)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return XDP_ABORTED;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>为了帮助 eBPF 校验器验证数据访问的合法性，在访问以太网头数据结构 <code>struct ethhdr</code> 之前，你需要检查数据指针是否越界。如果检查失败，就要返回一个错误（这儿返回的 <code>XDP_ABORTED</code> 表示丢弃数据包并记录错误行为以便排错）。</p><p>了解了太网头的访问格式之后，IP 头的访问也是类似的。在开始指针 <code>data</code> 之后加上太网头数据结构的长度偏移，就是 IP 头所指向的位置。拿到 IP 头之后，你还可以对网络数据进行初步的校验，比如忽略 IPv6、UDP 等我们不关心的数据，只处理 TCP 数据包，代码如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">struct iphdr *iph = data + sizeof(struct ethhdr);</span></div><div class="token-line"><span class="token plain">    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) &gt; data_end)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return XDP_ABORTED;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    if (eth-&gt;h_proto != bpf_htons(ETH_P_IP))</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return XDP_PASS;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    if (iph-&gt;protocol != IPPROTO_TCP)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      return XDP_PASS;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码中返回的 <code>XDP_PASS</code> 表示把网络包传递给内核协议栈，内核协议栈接收到网络包后，按正常流程继续处理。</p><p>进行了基本的校验之后，再接下来就是实现负载均衡的逻辑了。由于我们想要实现的是一个四层负载均衡，试想一下，负载均衡器收到客户端的请求之后，需要把目的地址（包括 IP 和 MAC）替换成后端 Webserver 的地址，再重新发到内核协议栈中继续处理。</p><p>参考内核中<a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/if_ether.h#L165">以太网头<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.13/source/include/uapi/linux/ip.h#L86">IP 头<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的定义格式， IP 地址都是以 <code>__be16</code> 类型的大端格式存储，而 MAC 地址则是以字符数组 <code>unsigned char h_dest[6]</code> 的形式存储。因而，MAC 地址可以直接通过数据下标进行访问，而我们案例开始时列出的 IP 地址，还需要先转换为 <code>__be16</code> 格式的大端存储格式。</p><p>如果你还不熟悉 IP 地址的转换方法，那可以参考下面的程序，调用 <code>inet_addr()</code> 库函数帮你完成转换：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#include &lt;stdio.h&gt;</span></div><div class="token-line"><span class="token plain">    #include &lt;arpa/inet.h&gt;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    int main() {</span></div><div class="token-line"><span class="token plain">      unsigned int a1 = inet_addr(&quot;172.17.0.2&quot;);</span></div><div class="token-line"><span class="token plain">      unsigned int a2 = inet_addr(&quot;172.17.0.3&quot;);</span></div><div class="token-line"><span class="token plain">      unsigned int a3 = inet_addr(&quot;172.17.0.4&quot;);</span></div><div class="token-line"><span class="token plain">      unsigned int a4 = inet_addr(&quot;172.17.0.5&quot;);</span></div><div class="token-line"><span class="token plain">      printf(&quot;0x%x 0x%x 0x%x 0x%x\n&quot;, a1, a2, a3, a4);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>为了方便你理解接下来的程序，我把转换后的容器地址信息整理成了一个表格，你可以在后续的开发和问题排查过程中参考：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimaged3bbd31389c380dc3dddf2128495d35b6ebb.d3c611f8.jpg" alt=""/></p><p>接下来，就是负载均衡的实现过程了，也就是根据请求的来源，把目的地址修改为 Webserver 的地址。下面的代码展示的就是一个最简单的负载均衡实现逻辑：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/* 1. 常量定义 */</span></div><div class="token-line"><span class="token plain">    #define CLIENT_IP 0x40011ac</span></div><div class="token-line"><span class="token plain">    #define LOADBALANCER_IP 0x50011ac</span></div><div class="token-line"><span class="token plain">    #define ENDPOINT1_IP 0x20011ac</span></div><div class="token-line"><span class="token plain">    #define ENDPOINT2_IP 0x30011ac</span></div><div class="token-line"><span class="token plain">    #define CLIENT_MAC_SUFFIX 0x04</span></div><div class="token-line"><span class="token plain">    #define LOADBALANCER_MAC_SUFFIX 0x05</span></div><div class="token-line"><span class="token plain">    #define ENDPOINT1_MAC_SUFFIX 0x02</span></div><div class="token-line"><span class="token plain">    #define ENDPOINT2_MAC_SUFFIX 0x03</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /* 2. 从客户端发送过来的请求，目的地址改为后端 Webserver 的地址 */</span></div><div class="token-line"><span class="token plain">    if (iph-&gt;saddr == CLIENT_IP)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      iph-&gt;daddr = ENDPOINT1_IP;</span></div><div class="token-line"><span class="token plain">      eth-&gt;h_dest[5] = ENDPOINT1_MAC_SUFFIX; /* Only need to update the last byte */</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      /* 模拟从两个Webserver随机选择 */</span></div><div class="token-line"><span class="token plain">      if ((bpf_ktime_get_ns() &amp; 0x1) == 0x1)</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">        iph-&gt;daddr = ENDPOINT2_IP;</span></div><div class="token-line"><span class="token plain">        eth-&gt;h_dest[5] = ENDPOINT2_MAC_SUFFIX;</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    else /* 3. 反之，目的地址改为客户端 */</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      iph-&gt;daddr = CLIENT_IP;</span></div><div class="token-line"><span class="token plain">      eth-&gt;h_dest[5] = CLIENT_MAC_SUFFIX;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /* 4. 修改原地址为LB地址 */</span></div><div class="token-line"><span class="token plain">    iph-&gt;saddr = LOADBALANCER_IP;</span></div><div class="token-line"><span class="token plain">    eth-&gt;h_source[5] = LOADBALANCER_MAC_SUFFIX;</span></div></pre></div><p>这段代码中各部分的含义如下：</p><ul><li>第 1 部分，将容器地址信息定义为常量，方便后续引用和理解。注意，MAC 地址是一个包含6 个元素的数组，而前 5 个元素的值都是相同的。因而，在更新目的 MAC 地址时，只需要更新最后一个元素即可。所以，常量定义里面也只包含了最后一个字节的值。</li><li>第 2 部分，对于从客户端发送过来的请求，将目的地址改为后端 Webserver 的地址。由于只有两个后端 Webserver，这儿使用时间戳最后一位的值模拟它们的随机选择过程。</li><li>第 3 部分，对于从 Webserver 发送过来的响应，目的地址改为客户端地址。</li><li>第 4 部分，将原地址都改为负载均衡器的地址。</li></ul><p>到这里， eBPF 程序是不是已经开发好了呢？其实，如果你了解过 IP 协议的基本原理，你就知道还有一个步骤也是非常重要的：由于修改了 IP 头的数据，IP 头的校验和（checksum）就需要重新计算，否则网络包会被内核直接丢弃。</p><p>如果你不熟悉 IP 头校验和的计算方法也没关系，你可以很容易从成熟的开源项目中查找到相关的计算方法。比如，参考 Facebook 开源的 <a target="_blank" rel="noopener noreferrer" href="https://github.com/facebookincubator/katran/blob/main/katran/lib/bpf/csum_helpers.h#L30">Katran<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，你可以定义如下的 <code>ipv4_csum()</code> 函数来计算校验和：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">static __always_inline __u16 csum_fold_helper(__u64 csum)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      int i;</span></div><div class="token-line"><span class="token plain">    #pragma unroll</span></div><div class="token-line"><span class="token plain">      for (i = 0; i &lt; 4; i++)</span></div><div class="token-line"><span class="token plain">      {</span></div><div class="token-line"><span class="token plain">      if (csum &gt;&gt; 16)</span></div><div class="token-line"><span class="token plain">        csum = (csum &amp; 0xffff) + (csum &gt;&gt; 16);</span></div><div class="token-line"><span class="token plain">      }</span></div><div class="token-line"><span class="token plain">      return ~csum;</span></div><div class="token-line"><span class="token plain">    }</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    static __always_inline __u16 ipv4_csum(struct iphdr *iph)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      iph-&gt;check = 0;</span></div><div class="token-line"><span class="token plain">      unsigned long long csum = bpf_csum_diff(0, 0, (unsigned int *)iph, sizeof(struct iphdr), 0);</span></div><div class="token-line"><span class="token plain">      return csum_fold_helper(csum);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>关于校验和的具体算法，你可以参考 TCP/IP 协议相关的原理书籍（如《TCP/IP详解》）来理解，这里我就不详细展开了。</p><p>有了校验和的计算方法之后，最后更新 IP 头的 checksum，再返回 <code>XDP_TX</code> 把数据包从原网卡发送出去，交给内核去转发就可以了。下面展示的就是更新校验和的实现方法：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">SEC(&quot;xdp&quot;)</span></div><div class="token-line"><span class="token plain">    int xdp_proxy(struct xdp_md *ctx)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">      /* 重新计算校验和 */</span></div><div class="token-line"><span class="token plain">      iph-&gt;check = ipv4_csum(iph);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      /* 把数据包从原网卡发送出去 */</span></div><div class="token-line"><span class="token plain">      return XDP_TX;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>把上述代码保存到一个文件 <code>xdp-proxy.bpf.c</code> 中，就完成了 XDP eBPF 程序的开发（你还可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/xdp/xdp-proxy.bpf.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中找到完整的代码）。</p><h3 id="编译并生成脚手架头文件"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#编译并生成脚手架头文件"><span class="icon icon-link"></span></a>编译并生成脚手架头文件</h3><p>有了 XDP 程序之后，接下来的第二步就比较简单了。我们只需要执行下面的 <code>clang</code> 命令，把 XDP 程序编译成字节码，再执行 <code>bpftool gen skeleton</code> 命令生成脚手架头文件即可：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clang -g -O2 -target bpf -D__TARGET_ARCH_x86 -I/usr/include/x86_64-linux-gnu -I. -c xdp-proxy.bpf.c -o xdp-proxy.bpf.o</span></div><div class="token-line"><span class="token plain">    bpftool gen skeleton xdp-proxy.bpf.o &gt; xdp-proxy.skel.h</span></div></pre></div><h3 id="开发用户态程序"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#开发用户态程序"><span class="icon icon-link"></span></a>开发用户态程序</h3><p>对于第三步用户态程序的开发，它的基本流程跟 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484372">08 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的内核跟踪案例是类似的，也是需要引入脚手架头文件、增大 RLIMIT_MEMLOCK、初始化并加载 BPF 字节码，最后再挂载 XDP 程序这几个步骤。忽略错误处理步骤，最核心的实现步骤如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">// 1. 引入脚手架头文件</span></div><div class="token-line"><span class="token plain">    #include &quot;xdp-proxy.skel.h&quot;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    // C语言主函数</span></div><div class="token-line"><span class="token plain">    int main(int argc, char **argv)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        // 2. 增大 RLIMIT_MEMLOCK（默认值通常太小，不足以存入BPF映射的内容）</span></div><div class="token-line"><span class="token plain">        struct rlimit rlim_new = {</span></div><div class="token-line"><span class="token plain">          .rlim_cur = RLIM_INFINITY,</span></div><div class="token-line"><span class="token plain">          .rlim_max = RLIM_INFINITY,</span></div><div class="token-line"><span class="token plain">        };</span></div><div class="token-line"><span class="token plain">        err = setrlimit(RLIMIT_MEMLOCK, &amp;rlim_new);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 3. 初始化BPF程序</span></div><div class="token-line"><span class="token plain">        struct xdp_proxy_bpf *obj = xdp_proxy_bpf__open();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 4. 加载BPF字节码</span></div><div class="token-line"><span class="token plain">        err = xdp_proxy_bpf__load(obj);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // 5. TODO: 挂载XDP程序到eth0网卡</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这段代码中，前面 4 个步骤跟 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484372">08 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的<a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/484372">内核跟踪案例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是一样的，这儿不再详细展开。</p><p>而对于第 5 步的挂载过程，我在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/483364">06 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中曾经提到，你可以使用 <code>ip link</code> 命令来挂载 XDP 程序。当时讲到的是在主机中挂载 XDP 的步骤，而在容器中的步骤其实也是一样的（注意，在容器中的虚拟网卡上，只支持以通用模式挂载）。</p><p>下面的代码展示的就是把 XDP 字节码复制到负载均衡容器并挂载到 eth0 网卡的过程：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 复制字节码到容器中</span></div><div class="token-line"><span class="token plain">    docker cp xdp-proxy.bpf.o lb:/</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 在容器中安装iproute2命令行工具</span></div><div class="token-line"><span class="token plain">    docker exec -it lb apk add iproute2 --update</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 在容器中挂载XDP程序到eth0网卡</span></div><div class="token-line"><span class="token plain">    docker exec -it lb ip link set dev eth0 xdpgeneric object xdp-proxy.bpf.o sec xdp</span></div></pre></div><p>除了使用命令行工具之外，你还可以在用户态程序中调用库函数来挂载 XDP 程序，从而避免引入额外的命令行工具依赖（比如，不再需要安装 iproute2 系统工具）。</p><p>libbpf 提供了一个 <code>bpf_set_link_xdp_fd(int ifindex, int fd, __u32 flags)</code> 函数，可用于把 XDP 程序挂载到网卡。这个函数需要网卡序号和 XDP 程序文件描述符作为参数，查询这些参数并挂载 XDP 的过程如下所示：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">unsigned int ifindex = if_nametoindex(&quot;eth0&quot;);</span></div><div class="token-line"><span class="token plain">        int prog_id = bpf_program__fd(obj-&gt;progs.xdp_proxy);</span></div><div class="token-line"><span class="token plain">        err = bpf_set_link_xdp_fd(ifindex, prog_id, XDP_FLAGS_UPDATE_IF_NOEXIST|XDP_FLAGS_SKB_MODE);</span></div></pre></div><p>这段代码中，挂载参数标志 <code>XDP_FLAGS_SKB_MODE</code> 等同于 <code>ip link</code> 命令中的 <code>xdpgeneric</code>，表示以通用模式挂载。</p><p>把上述代码保存到 <code>xdp-proxy.c</code> 文件中（你还可以在 <a target="_blank" rel="noopener noreferrer" href="https://github.com/feiskyer/ebpf-apps/blob/main/loadbalancer/xdp/xdp-proxy.c">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中找到完整的代码），再执行下面的编译命令，就可以将其编译为静态链接的可执行文件。采用静态链接的一个好处是容易在容器中分发，只需要把最终的二进制文件放入容器中即可运行，不再需要安装额外的依赖环境。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">clang -g -O2 -Wall -I. -c xdp-proxy.c -o xdp-proxy.o</span></div><div class="token-line"><span class="token plain">    clang -Wall -O2 -g xdp-proxy.o -static -lbpf -lelf -lz -o xdp-proxy</span></div></pre></div><p>到这里，完整的 eBPF 程序就开发好了。它是不是可以正常工作呢？如果可以正常工作，性能又会怎么样？接下来，我们把它放到容器中测试一下看看。</p><h3 id="性能测试"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#性能测试"><span class="icon icon-link"></span></a>性能测试</h3><p>在终端中执行下面的 docker 命令，把 XDP 程序复制到负载均衡容器中，并执行 XDP 程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># 复制XDP程序到容器</span></div><div class="token-line"><span class="token plain">    docker cp xdp-proxy lb:/</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 在容器中加载XDP程序</span></div><div class="token-line"><span class="token plain">    docker exec -it lb /xdp-proxy</span></div></pre></div><p>然后，进入客户端容器终端中，执行 <code>apk</code> 命令安装 <code>curl</code> 和 <code>wrk</code> 工具，接着再使用 <code>curl</code> 访问负载均衡器：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">docker exec -it client sh</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # (以下命令运行在client容器中)</span></div><div class="token-line"><span class="token plain">    / # curl &quot;http://172.17.0.5&quot;</span></div></pre></div><p>如果你看到 <code>Hostname: http1</code> 或者 <code>Hostname: http12</code> 的输出，说明 XDP 已经成功运行，并且它的负载均衡功能也是正常的。</p><p>接下来，继续在客户端容器终端中执行 <code>wrk</code> 命令，给负载均衡器做个性能测试：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># (以下命令运行在client容器中)</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 安装wrk工具</span></div><div class="token-line"><span class="token plain">    / # apk add curl wrk --update</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # 执行性能测试</span></div><div class="token-line"><span class="token plain">    / # wrk -c100 &quot;http://172.17.0.5&quot;</span></div></pre></div><p>稍等一会，你会看到如下的输出（在你的环境下可能看到不同数值，具体的性能指标取决于运行环境和配置）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">Running 10s test @ http://172.17.0.5</span></div><div class="token-line"><span class="token plain">      2 threads and 100 connections</span></div><div class="token-line"><span class="token plain">      Thread Stats   Avg      Stdev     Max   +/- Stdev</span></div><div class="token-line"><span class="token plain">        Latency     6.37ms   11.17ms 295.43ms   98.97%</span></div><div class="token-line"><span class="token plain">        Req/Sec     9.09k   422.06    10.09k    75.00%</span></div><div class="token-line"><span class="token plain">      180889 requests in 10.02s, 31.39MB read</span></div><div class="token-line"><span class="token plain">    Requests/sec:  18048.65</span></div><div class="token-line"><span class="token plain">    Transfer/sec:      3.13MB</span></div></pre></div><p>从输出中你可以看到，平均每秒请求数是 18048，每个线程的平均延迟是 6.37ms。回顾一下 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/485702?cid=100104501">12 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中的套接字 eBPF 程序的性能测试结果，它的平均每秒请求数是 15300，而每个线程的平均延迟是 6.88ms。这说明，相比套接字程序，XDP 程序在平均每秒请求数上提升了 18%。</p><p>最后，不要忘记清理今天的案例环境。由于所有服务都运行在容器中，我们只需要执行下面的命令，删除今天创建的所有容器，即可完成清理工作：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">docker rm -f lb client http1 http2</span></div></pre></div><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天，我带你使用 libbpf 开发了一个基于 XDP 的负载均衡服务。</p><p>XDP 程序在网络驱动程序刚刚收到数据包的时候触发执行。由于还未分配内核 SKB 数据结构，XDP 程序只能根据 TCP/IP 协议的封包格式，从原始网络包中提取所需协议层的数据，进而再按照需要进行改写或转发。XDP 程序修改过的数据包可以转发给相同或不同的网卡，再交给内核协议栈继续处理；或者，跟处理逻辑无关的包不做任何处理，直接交给内核协议栈进行处理。</p><p>今天的案例把 XDP 程序挂载到了容器的虚拟网卡上，由于采用了通用模式挂载，它的执行过程其实还是在内核中运行的。在实际生产环境中，你可以以原生模式或卸载模式把 XDP 程序挂载到支持 XDP 的网卡上，从而获得最优的网络性能。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后，我想邀请你来聊一聊：</p><ol><li>在今天的案例中，我们把 XDP 程序挂载到了负载均衡容器中的网卡上。如果把它直接挂载到主机的 eth0 网卡，会有什么样的现象？</li><li>针对今天的负载均衡场景，还有哪些方法可以进一步优化 XDP 程序的性能？</li></ol><p>期待你在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。让我们一起在实战中演练，在交流中进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/ebpf核心技术与实战/04.实战进阶篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:48:00</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect3/umi.0a9ffe80.js"></script>
  </body>
</html>
