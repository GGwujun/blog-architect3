<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect3/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect3";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>04 | 运行原理：eBPF 是一个新的虚拟机吗？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/ebpf核心技术与实战/03.基础入门篇/02" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/01.开篇词/01"><span>开篇词 | 想要洞悉系统底层的黑盒？先掌握 eBPF！</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇">02.学习准备篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/01"><span>01｜技术概览：eBPF 的发展历程及工作原理</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/02.学习准备篇/02"><span>02 | 先利其器：如何高效学习 eBPF？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇">03.基础入门篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/01"><span>03 | 初窥门径：开发并运行你的第一个 eBPF 程序</span></a></li><li><a aria-current="page" class="active" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02"><span>04 | 运行原理：eBPF 是一个新的虚拟机吗？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/03"><span>05 | 编程接口：eBPF 程序是怎么跟内核进行交互的？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/04"><span>06 | 事件触发：各类 eBPF 程序的触发机制及其应用场景</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇">04.实战进阶篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/01"><span>07 | 内核跟踪（上）：如何查询内核中的跟踪点？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/02"><span>08｜内核跟踪（下）：开发内核跟踪程序的进阶方法</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/03"><span>09 | 用户态跟踪：如何使用 eBPF 排查应用程序？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/04"><span>10 | 网络跟踪：如何使用 eBPF 排查网络问题？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/05"><span>11 | 容器安全：如何使用 eBPF 增强容器安全？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/06"><span>12｜高性能网络实战（上）：如何开发一个负载均衡器？</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/04.实战进阶篇/07"><span>13｜高性能网络实战（下）：如何完善负载均衡器？</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结">05.阶段总结</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/01"><span>阶段总结｜实用 eBPF 工具及最新开源项目总结</span></a></li><li><a href="/blog-architect3/ebpf核心技术与实战/05.阶段总结/02"><span>未来可期｜邀你与 eBPF 共赴一场技术革新之约</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇">06.技术雷达篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/06.技术雷达篇/01"><span>难点解析｜eBPF 开发环境搭建及内核编译详解</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇">07.加餐篇</a><ul><li><a href="/blog-architect3/ebpf核心技术与实战/07.加餐篇/01"><span>加餐｜李程远：谈谈 eBPF 在云原生中的纵与横</span></a></li></ul></li><li><a href="/blog-architect3/ebpf核心技术与实战/summary">ebpf核心技术与实战</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="eBPF 虚拟机是如何工作的？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#ebpf-虚拟机是如何工作的"><span>eBPF 虚拟机是如何工作的？</span></a></li><li title="BPF 指令是什么样的？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#bpf-指令是什么样的"><span>BPF 指令是什么样的？</span></a></li><li title="eBPF 程序是什么时候执行的？" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#ebpf-程序是什么时候执行的"><span>eBPF 程序是什么时候执行的？</span></a></li><li title="小结" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#小结"><span>小结</span></a></li><li title="思考题" data-depth="2"><a href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="04--运行原理ebpf-是一个新的虚拟机吗"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#04--运行原理ebpf-是一个新的虚拟机吗"><span class="icon icon-link"></span></a>04 | 运行原理：eBPF 是一个新的虚拟机吗？</h1><p>你好，我是倪朋飞。</p><p>上一讲，我带你一起搭建了 eBPF 的开发环境，并从最简单的 Hello World 开始，带你借助 BCC 库从零开发了一个跟踪 <a target="_blank" rel="noopener noreferrer" href="https://man7.org/linux/man-pages/man2/open.2.html">openat()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 系统调用的 eBPF 程序。</p><p>不过，虽然第一个 eBPF 程序已经成功运行起来了，你很可能还在想：这个 eBPF 程序到底是如何编译成内核可识别的格式的？又是如何在内核中运行起来的？还有，既然允许普通用户去修改内核的行为，它又是如何确保内核安全的呢？</p><p>今天，我就带你一起深入看看 eBPF 虚拟机的原理，以及 eBPF 程序是如何执行的。</p><h2 id="ebpf-虚拟机是如何工作的"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#ebpf-虚拟机是如何工作的"><span class="icon icon-link"></span></a>eBPF 虚拟机是如何工作的？</h2><p>eBPF 是一个运行在内核中的虚拟机，很多人在初次接触它时，会把它跟系统虚拟化（比如kvm）中的虚拟机弄混。其实，虽然都被称为“虚拟机”，系统虚拟化和 eBPF 虚拟机还是有着本质不同的。</p><p>系统虚拟化基于 x86 或 arm64 等通用指令集，这些指令集足以完成完整计算机的所有功能。而为了确保在内核中安全地执行，eBPF 只提供了非常有限的指令集。这些指令集可用于完成一部分内核的功能，但却远不足以模拟完整的计算机。为了更高效地与内核进行交互，eBPF 指令还有意采用了 C 调用约定，其提供的辅助函数可以在 C 语言中直接调用，极大地方便了 eBPF 程序的开发。</p><p>如下图（图片来自 <a target="_blank" rel="noopener noreferrer" href="https://www.usenix.org/conference/lisa21/presentation/gregg-bpf">BPF Internals<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）所示，eBPF 在内核中的运行时主要由 5 个模块组成：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimage45d2453f8d99cea1b35da8f6c57e552yy3d2.c1f1bc3f.png" alt="图片" title="eBPF 运行时"/></p><ul><li>第一个模块是 <strong>eBPF 辅助函数</strong>。它提供了一系列用于 eBPF 程序与内核其他模块进行交互的函数。这些函数并不是任意一个 eBPF 程序都可以调用的，具体可用的函数集由 BPF 程序类型决定。关于 BPF 程序类型，我会在 06 讲 中进行讲解。</li><li>第二个模块是 <strong>eBPF 验证器</strong>。它用于确保 eBPF 程序的安全。验证器会将待执行的指令创建为一个有向无环图（DAG），确保程序中不包含不可达指令；接着再模拟指令的执行过程，确保不会执行无效指令。</li><li>第三个模块是由 <strong>11 个 64 位寄存器、一个程序计数器和一个 512 字节的栈组成的存储模块</strong>。这个模块用于控制 eBPF 程序的执行。其中，R0 寄存器用于存储函数调用和 eBPF 程序的返回值，这意味着函数调用最多只能有一个返回值；R1-R5 寄存器用于函数调用的参数，因此函数调用的参数最多不能超过 5 个；而 R10 则是一个只读寄存器，用于从栈中读取数据。</li><li>第四个模块是<strong>即时编译器</strong>，它将 eBPF 字节码编译成本地机器指令，以便更高效地在内核中执行。</li><li>第五个模块是 <strong>BPF 映射（map）</strong>，它用于提供大块的存储。这些存储可被用户空间程序用来进行访问，进而控制 eBPF 程序的运行状态。</li></ul><p>关于 BPF 辅助函数和 BPF 映射的具体内容，我在后面的课程中还会为你详细介绍。接下来，我们先来看看 BPF 指令的具体格式，以及它是如何加载到内核中，又是何时运行的。</p><h2 id="bpf-指令是什么样的"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#bpf-指令是什么样的"><span class="icon icon-link"></span></a>BPF 指令是什么样的？</h2><p>只看图中的这些模块，你可能觉得它们并不是太直观。所以接下来，我们还是用上一讲的 Hello World 作为例子，一起看下 BPF 指令到底是什么样子的。</p><p>首先，回顾一下上一讲的 eBPF 程序 Hello World 的源代码。它的逻辑其实很简单，先调用  <code>bpf_trace_printk</code> 输出一个 “Hello, World!” 字符串，然后就返回成功了：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int hello_world(void *ctx)</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">      bpf_trace_printk(&quot;Hello, World!&quot;);</span></div><div class="token-line"><span class="token plain">      return 0;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>然后，我们通过 BCC 的 Python 库，加载并运行了这个 eBPF 程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">#!/usr/bin/env python3</span></div><div class="token-line"><span class="token plain">    # This is a Hello World example of BPF.</span></div><div class="token-line"><span class="token plain">    from bcc import BPF</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    # load BPF program</span></div><div class="token-line"><span class="token plain">    b = BPF(src_file=&quot;hello.c&quot;)</span></div><div class="token-line"><span class="token plain">    b.attach_kprobe(event=&quot;do_sys_openat2&quot;, fn_name=&quot;hello_world&quot;)</span></div><div class="token-line"><span class="token plain">    b.trace_print()</span></div></pre></div><p>在终端中运行下面的命令，就可以启动这个 eBPF 程序（注意， BCC 帮你完成了编译和加载的过程）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo python3 hello.py</span></div></pre></div><p><strong>接下来，我为你介绍一个新的工具 bpftool，<strong><strong>用它可以</strong></strong>查看 eBPF 程序的运行状态。</strong></p><p>首先，打开一个新的终端，执行下面的命令，查询系统中正在运行的 eBPF 程序：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># sudo bpftool prog list</span></div><div class="token-line"><span class="token plain">    89: kprobe  name hello_world  tag 38dd440716c4900f  gpl</span></div><div class="token-line"><span class="token plain">          loaded_at 2021-11-27T13:20:45+0000  uid 0</span></div><div class="token-line"><span class="token plain">          xlated 104B  jited 70B  memlock 4096B</span></div><div class="token-line"><span class="token plain">          btf_id 131</span></div><div class="token-line"><span class="token plain">          pids python3(152027)</span></div></pre></div><p>输出中，89 是这个 eBPF 程序的编号，kprobe 是程序的类型，而 hello_world 是程序的名字。</p><p>有了 eBPF 程序编号之后，执行下面的命令就可以导出这个 eBPF 程序的指令（注意把 89 替换成你查询到的编号）：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo bpftool prog dump xlated id 89</span></div></pre></div><p>你会看到如下所示的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int hello_world(void * ctx):</span></div><div class="token-line"><span class="token plain">    ; int hello_world(void *ctx)</span></div><div class="token-line"><span class="token plain">       0: (b7) r1 = 33                  /* ! */</span></div><div class="token-line"><span class="token plain">    ; ({ char _fmt[] = &quot;Hello, World!&quot;; bpf_trace_printk_(_fmt, sizeof(_fmt)); });</span></div><div class="token-line"><span class="token plain">       1: (6b) *(u16 *)(r10 -4) = r1</span></div><div class="token-line"><span class="token plain">       2: (b7) r1 = 1684828783          /* dlro */</span></div><div class="token-line"><span class="token plain">       3: (63) *(u32 *)(r10 -8) = r1</span></div><div class="token-line"><span class="token plain">       4: (18) r1 = 0x57202c6f6c6c6548  /* W ,olleH */</span></div><div class="token-line"><span class="token plain">       6: (7b) *(u64 *)(r10 -16) = r1</span></div><div class="token-line"><span class="token plain">       7: (bf) r1 = r10</span></div><div class="token-line"><span class="token plain">    ;</span></div><div class="token-line"><span class="token plain">       8: (07) r1 += -16</span></div><div class="token-line"><span class="token plain">    ; ({ char _fmt[] = &quot;Hello, World!&quot;; bpf_trace_printk_(_fmt, sizeof(_fmt)); });</span></div><div class="token-line"><span class="token plain">       9: (b7) r2 = 14</span></div><div class="token-line"><span class="token plain">      10: (85) call bpf_trace_printk#-61616</span></div><div class="token-line"><span class="token plain">    ; return 0;</span></div><div class="token-line"><span class="token plain">      11: (b7) r0 = 0</span></div><div class="token-line"><span class="token plain">      12: (95) exit</span></div></pre></div><p>其中，分号开头的部分，正是我们前面写的 C 代码，而其他行则是具体的 BPF 指令。具体每一行的 BPF 指令又分为三部分：</p><ul><li>第一部分，冒号前面的数字 0-12 ，代表 BPF 指令行数；</li><li>第二部分，括号中的16进制数值，表示 BPF 指令码。它的具体含义你可以参考 <a target="_blank" rel="noopener noreferrer" href="https://github.com/iovisor/bpf-docs/blob/master/eBPF.md">IOVisor BPF 文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，比如第 0 行的 0xb7 表示为 64 位寄存器赋值。</li><li>第三部分，括号后面的部分，就是 BPF 指令的伪代码。</li></ul><p>结合前面讲述的各个寄存器的作用，不难理解这些 BPF 指令的含义：</p><ul><li>第0-8行，借助 R10 寄存器从栈中把字符串 “Hello, World!” 读出来，并放入 R1 寄存器中；</li><li>第9行，向 R2 寄存器写入字符串的长度 14（即代码注释里面的 <code>sizeof(_fmt)</code> ）；</li><li>第10行，调用 BPF 辅助函数 <code>bpf_trace_printk</code> 输出字符串；</li><li>第11行，向 R0 寄存器写入0，表示程序的返回值是0；</li><li>最后一行，程序执行成功退出。</li></ul><p>总结起来，<strong>这些指令先通过 R1 和 R2 寄存器设置了</strong> <code>bpf_trace_printk</code> <strong>的参数，然后调用</strong> <code>bpf_trace_printk</code> <strong>函数输出字符串，最后再通过 R0 寄存器返回成功。</strong></p><p>实际上，你也可以通过类似的 <a target="_blank" rel="noopener noreferrer" href="https://man7.org/linux/man-pages/man2/bpf.2.html#EXAMPLES">BPF 指令<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来开发 eBPF 程序（具体指令的定义，请参考 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.4/source/include/uapi/linux/bpf_common.h">include/uapi/linux/bpf_common.h<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 以及 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.4/source/include/uapi/linux/bpf.h">include/uapi/linux/bpf.h<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），不过通常并不推荐你这么做。跟一开始的 C 程序相比，你会发现 BPF 指令的可读性和可维护性明显要差得多。所以，我建议你还是使用 C 语言来开发 eBPF 程序，而只把 BPF 指令作为排查 eBPF 程序疑难杂症时的参考。</p><p>这里，我来简单讲讲 BPF 指令加载后是如何运行的。当这些 BPF 指令加载到内核后， BPF 即时编译器会将其编译成本地机器指令，最后才会执行编译后的机器指令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># bpftool prog dump jited id 89</span></div><div class="token-line"><span class="token plain">    int hello_world(void * ctx):</span></div><div class="token-line"><span class="token plain">    bpf_prog_38dd440716c4900f_hello_world:</span></div><div class="token-line"><span class="token plain">    ; int hello_world(void *ctx)</span></div><div class="token-line"><span class="token plain">       0:	nopl   0x0(%rax,%rax,1)</span></div><div class="token-line"><span class="token plain">       5:	xchg   %ax,%ax</span></div><div class="token-line"><span class="token plain">       7:	push   %rbp</span></div><div class="token-line"><span class="token plain">       8:	mov    %rsp,%rbp</span></div><div class="token-line"><span class="token plain">       b:	sub    $0x10,%rsp</span></div><div class="token-line"><span class="token plain">      12:	mov    $0x21,%edi</span></div><div class="token-line"><span class="token plain">    ; ({ char _fmt[] = &quot;Hello, World!&quot;; bpf_trace_printk_(_fmt, sizeof(_fmt)); });</span></div><div class="token-line"><span class="token plain">      17:	mov    %di,-0x4(%rbp)</span></div><div class="token-line"><span class="token plain">      1b:	mov    $0x646c726f,%edi</span></div><div class="token-line"><span class="token plain">      20:	mov    %edi,-0x8(%rbp)</span></div><div class="token-line"><span class="token plain">      23:	movabs $0x57202c6f6c6c6548,%rdi</span></div><div class="token-line"><span class="token plain">      2d:	mov    %rdi,-0x10(%rbp)</span></div><div class="token-line"><span class="token plain">      31:	mov    %rbp,%rdi</span></div><div class="token-line"><span class="token plain">    ;</span></div><div class="token-line"><span class="token plain">      34:	add    $0xfffffffffffffff0,%rdi</span></div><div class="token-line"><span class="token plain">    ; ({ char _fmt[] = &quot;Hello, World!&quot;; bpf_trace_printk_(_fmt, sizeof(_fmt)); });</span></div><div class="token-line"><span class="token plain">      38:	mov    $0xe,%esi</span></div><div class="token-line"><span class="token plain">      3d:	call   0xffffffffd8c7e834</span></div><div class="token-line"><span class="token plain">    ; return 0;</span></div><div class="token-line"><span class="token plain">      42:	xor    %eax,%eax</span></div><div class="token-line"><span class="token plain">      44:	leave</span></div><div class="token-line"><span class="token plain">      45:	ret</span></div></pre></div><p>这些机器指令的含义跟前面的 BPF 指令是类似的，但具体的指令和寄存器都换成了 x86 的格式。你不需要掌握这些机器指令的具体含义，只要知道查询的具体方法就足够了。这是因为，就像你曾接触过的其他高级语言一样，在实际的 eBPF 使用过程中，并不需要直接使用机器指令，而是 eBPF 虚拟机帮你自动完成了转换。</p><h2 id="ebpf-程序是什么时候执行的"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#ebpf-程序是什么时候执行的"><span class="icon icon-link"></span></a>eBPF 程序是什么时候执行的？</h2><p>到这里，我想你已经理解了 BPF 指令的具体格式，以及它与 C 源代码之间的对应关系。不过，这个 eBPF 程序到底是什么时候执行的呢？接下来，我们再一起看看 BPF 指令的加载和执行过程。</p><p>在上一讲中我提到，BCC 负责了 eBPF 程序的编译和加载过程。因而，要了解 BPF 指令的加载过程，就可以从 BCC 执行 eBPF 程序的过程入手。</p><p>那么，怎么才能查看到 BCC 的执行过程呢？我想，你一定想到了，那就是跟踪它的系统调用过程。</p><p>首先，我们打开一个终端，执行下面的命令：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain"># -ebpf表示只跟踪bpf系统调用</span></div><div class="token-line"><span class="token plain">    sudo strace -v -f -ebpf ./hello.py</span></div></pre></div><p>稍等一会，你会看到如下的输出：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">bpf(BPF_PROG_LOAD,</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            prog_type=BPF_PROG_TYPE_KPROBE,</span></div><div class="token-line"><span class="token plain">            insn_cnt=13,</span></div><div class="token-line"><span class="token plain">            insns=[</span></div><div class="token-line"><span class="token plain">                {code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x21},</span></div><div class="token-line"><span class="token plain">                {code=BPF_STX|BPF_H|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-4, imm=0},</span></div><div class="token-line"><span class="token plain">                {code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x646c726f},</span></div><div class="token-line"><span class="token plain">                {code=BPF_STX|BPF_W|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-8, imm=0},</span></div><div class="token-line"><span class="token plain">                {code=BPF_LD|BPF_DW|BPF_IMM, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0x6c6c6548},</span></div><div class="token-line"><span class="token plain">                {code=BPF_LD|BPF_W|BPF_IMM, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x57202c6f},</span></div><div class="token-line"><span class="token plain">                {code=BPF_STX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-16, imm=0},</span></div><div class="token-line"><span class="token plain">                {code=BPF_ALU64|BPF_X|BPF_MOV, dst_reg=BPF_REG_1, src_reg=BPF_REG_10, off=0, imm=0},</span></div><div class="token-line"><span class="token plain">                {code=BPF_ALU64|BPF_K|BPF_ADD, dst_reg=BPF_REG_1, src_reg=BPF_REG_0, off=0, imm=0xfffffff0},</span></div><div class="token-line"><span class="token plain">                {code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_2, src_reg=BPF_REG_0, off=0, imm=0xe},</span></div><div class="token-line"><span class="token plain">                {code=BPF_JMP|BPF_K|BPF_CALL, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x6},</span></div><div class="token-line"><span class="token plain">                {code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0},</span></div><div class="token-line"><span class="token plain">                {code=BPF_JMP|BPF_K|BPF_EXIT, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0}</span></div><div class="token-line"><span class="token plain">            ],</span></div><div class="token-line"><span class="token plain">            prog_name=&quot;hello_world&quot;,</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        128) = 4</span></div></pre></div><p>这些参数看起来很复杂，但实际上，如果你查询 <code>bpf</code> 系统调用的格式（执行 <code>man bpf</code> 命令），就可以发现，它实际上只需要三个参数：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">int bpf(int cmd, union bpf_attr *attr, unsigned int size);</span></div></pre></div><p>对应前面的 strace 输出结果，这三个参数的具体含义如下。</p><ul><li>第一个参数是 <code>BPF_PROG_LOAD</code> ， 表示加载 BPF 程序。</li><li>第二个参数是 <code>bpf_attr</code> 类型的结构体，表示 BPF 程序的属性。其中，有几个需要你留意的参数，比如：<ul><li><code>prog_type</code> 表示 BPF 程序的类型，这儿是 <code>BPF_PROG_TYPE_KPROBE</code> ，跟我们Python 代码中的 <code>attach_kprobe</code> 一致；</li><li><code>insn_cnt</code> (instructions count) 表示指令条数；</li><li><code>insns</code> (instructions) 包含了具体的每一条指令，这儿的 13 条指令跟我们前面 <code>bpftool prog dump</code> 的结果是一致的（具体的指令格式，你可以参考内核中 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.4/source/include/uapi/linux/bpf.h#L65">bpf_insn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的定义）；</li><li><code>prog_name</code> 则表示 BPF 程序的名字，即 <code>hello_world</code> 。</li></ul></li><li>第三个参数 128 表示属性的大小。</li></ul><p>到这里，我们已经了解了 bpf 系统调用的基本格式。对于 <code>bpf</code> 系统调用在内核中的实现原理，你并不需要详细了解。我们只要知道它的具体功能，就可以掌握 eBPF 的核心原理了。当然，如果你对它的实现方法有兴趣的话，可以参考内核源码 kernel/bpf/syscall.c 中 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.4/source/kernel/bpf/syscall.c#L2837">SYSCALL_DEFINE3<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的实现。</p><p>BPF 程序加载到内核后，并不会立刻执行，那么它什么时候才会执行呢？这里，回想一下我在 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/479384">01 讲<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中提到的 eBPF 的基本原理：</p><blockquote><p>eBPF 程序并不像常规的线程那样，启动后就一直运行在那里，它需要事件触发后才会执行。这些事件包括系统调用、内核跟踪点、内核函数和用户态函数的调用退出、网络事件，等等。</p></blockquote><p>对于我们的 Hello World 来说，由于调用了 <code>attach_kprobe</code> 函数，很明显，这是一个内核跟踪事件：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">b.attach_kprobe(event=&quot;do_sys_openat2&quot;, fn_name=&quot;hello_world&quot;)</span></div></pre></div><p>所以，除了把 eBPF 程序加载到内核之外，还需要把加载后的程序跟具体的内核函数调用事件进行绑定。在 eBPF 的实现中，诸如内核跟踪（kprobe）、用户跟踪（uprobe）等的事件绑定，都是通过 <code>perf_event_open()</code> 来完成的。</p><p>为什么这么说呢？我们再用 <code>strace</code> 来确认一下。把前面 <code>strace</code> 命令中的 <code>-ebpf</code> 参数去掉，重新执行：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">sudo strace -v -f ./hello.py</span></div></pre></div><p>忽略无关的输出后，你会发现如下的系统调用：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">...</span></div><div class="token-line"><span class="token plain">    /* 1) 加载BPF程序 */</span></div><div class="token-line"><span class="token plain">    bpf(BPF_PROG_LOAD,...) = 4</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /* 2）查询事件类型 */</span></div><div class="token-line"><span class="token plain">    openat(AT_FDCWD, &quot;/sys/bus/event_source/devices/kprobe/type&quot;, O_RDONLY) = 5</span></div><div class="token-line"><span class="token plain">    read(5, &quot;6\n&quot;, 4096)                    = 2</span></div><div class="token-line"><span class="token plain">    close(5)                                = 0</span></div><div class="token-line"><span class="token plain">    ...</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /* 3）创建性能监控事件 */</span></div><div class="token-line"><span class="token plain">    perf_event_open(</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            type=0x6 /* PERF_TYPE_??? */,</span></div><div class="token-line"><span class="token plain">            size=PERF_ATTR_SIZE_VER7,</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">            wakeup_events=1,</span></div><div class="token-line"><span class="token plain">            config1=0x7f275d195c50,</span></div><div class="token-line"><span class="token plain">            ...</span></div><div class="token-line"><span class="token plain">        },</span></div><div class="token-line"><span class="token plain">        -1,</span></div><div class="token-line"><span class="token plain">        0,</span></div><div class="token-line"><span class="token plain">        -1,</span></div><div class="token-line"><span class="token plain">        PERF_FLAG_FD_CLOEXEC) = 5</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    /* 4）绑定BPF到kprobe事件 */</span></div><div class="token-line"><span class="token plain">    ioctl(5, PERF_EVENT_IOC_SET_BPF, 4)     = 0</span></div><div class="token-line"><span class="token plain">    ...</span></div></pre></div><p>从输出中，你可以看出 BPF 与性能事件的绑定过程分为以下几步：</p><ul><li>首先，借助 bpf 系统调用，加载 BPF 程序，并记住返回的文件描述符；</li><li>然后，查询 kprobe 类型的事件编号。BCC 实际上是通过 <code>/sys/bus/event_source/devices/kprobe/type</code> 来查询的；</li><li>接着，调用 <code>perf_event_open</code> 创建性能监控事件。比如，事件类型（type 是上一步查询到的 6）、事件的参数（ <code>config1 包含了内核函数 do_sys_openat2</code> ）等；</li><li>最后，再通过 <code>ioctl</code> 的 <code>PERF_EVENT_IOC_SET_BPF</code> 命令，将 BPF 程序绑定到性能监控事件。</li></ul><p>对于绑定性能监控（perf event）的内核实现原理，你也不需要详细了解，只需要知道它的具体功能，就足够我们掌握 eBPF 了。如果你对它的实现方法有兴趣的话，可以参考内核源码 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.4/source/kernel/events/core.c#L9039">perf_event_set_bpf_prog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的实现；而最终性能监控调用 BPF 程序的实现，则可以参考内核源码 <a target="_blank" rel="noopener noreferrer" href="https://elixir.bootlin.com/linux/v5.4/source/kernel/trace/trace_kprobe.c#L1351">kprobe_perf_func<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的实现。</p><h2 id="小结"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#小结"><span class="icon icon-link"></span></a>小结</h2><p>今天，我带你一起梳理了 eBPF 在内核中的实现原理，并以上一讲的 Hello World 程序为例，借助 bpftool、strace 等工具，带你观察了 BPF 指令的具体格式。</p><p>然后，我们从 BCC 执行 eBPF 程序的过程入手，一起看了BPF 指令的加载和执行过程。用高级语言开发的 eBPF 程序，需要首先编译为 BPF 字节码（即 BPF 指令），然后借助 <code>bpf</code> 系统调用加载到内核中，最后再通过性能监控等接口，与具体的内核事件进行绑定。这样，内核的性能监控模块才会在内核事件发生时，自动执行我们开发的 eBPF 程序。</p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/ebpf核心技术与实战/03.基础入门篇/02#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>最后，我想邀请你来聊一聊这两个问题。</p><ol><li>你通常是如何快速理解一门新技术的运行原理的？</li><li>在今天的内容中，我使用 strace 跟踪 BCC 程序，进而找到了相关的系统调用。那么，有没有可能直接使用 BCC 来跟踪 <code>bpf</code> 系统调用呢？如果你的答案是肯定的，可以试着把它开发出来，并在评论区分享你的实践经验。</li></ol><p>欢迎在留言区和我讨论，也欢迎把这节课分享给你的同事、朋友。我们一起在实战中演练，在交流中进步。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/ebpf核心技术与实战/03.基础入门篇/02.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:48:00</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect3/umi.0a9ffe80.js"></script>
  </body>
</html>
