<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-architect3/umi.3ec1f225.css" />
    <script>
      window.routerBase = "/blog-architect3";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>19 | 比较：Jetty的线程策略EatWhatYouKill - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/深入拆解tomcat和jetty/04.模块三连接器/06" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-architect3/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>架构师<ul><li><a href="/blog-architect3/持续交付36讲">持续交付36讲</a></li><li><a href="/blog-architect3/容器实战高手课">容器实战高手课</a></li><li><a href="/blog-architect3/ddd实战课">ddd实战课</a></li><li><a href="/blog-architect3/devops实战笔记">devops实战笔记</a></li><li><a href="/blog-architect3/ebpf核心技术与实战">ebpf核心技术与实战</a></li><li><a href="/blog-architect3/深入剖析kubernetes">深入剖析kubernetes</a></li><li><a href="/blog-architect3/openresty从入门到实战">openresty从入门到实战</a></li><li><a href="/blog-architect3/赵成的运维体系管理课">赵成的运维体系管理课</a></li><li><a href="/blog-architect3/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-architect3/安全攻防技能30讲">安全攻防技能30讲</a></li><li><a href="/blog-architect3/容量保障核心技术与实战">容量保障核心技术与实战</a></li><li><a aria-current="page" class="active" href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-architect3/深入拆解tomcat和jetty">深入拆解tomcat和jetty</a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/01.开篇词">01.开篇词</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/01.开篇词/01"><span>开篇词 | Java程序员如何快速成长？</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/02.模块一必备基础">02.模块一必备基础</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/02.模块一必备基础/01"><span>01 | Web容器学习路径</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/02.模块一必备基础/02"><span>02 | HTTP协议必知必会</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/02.模块一必备基础/03"><span>03 | 你应该知道的Servlet规范和Servlet容器</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/02.模块一必备基础/04"><span>04 | 实战：纯手工打造和运行一个Servlet</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构">03.模块二整体架构</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/01"><span>05 | Tomcat系统架构（上）： 连接器是如何设计的？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/02"><span>06 | Tomcat系统架构（下）：聊聊多层容器的设计</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/03"><span>07 | Tomcat如何实现一键式启停？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/04"><span>08 | Tomcat的“高层们”都负责做什么？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/05"><span>09 | 比较：Jetty架构特点之Connector组件</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/06"><span>10 | 比较：Jetty架构特点之Handler组件</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/07"><span>11 | 总结：从Tomcat和Jetty中提炼组件化设计规范</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/08"><span>12 | 实战：优化并提高Tomcat启动速度</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/03.模块二整体架构/09"><span>13 | 热点问题答疑（1）：如何学习源码？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器">04.模块三连接器</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/01"><span>14 | NioEndpoint组件：Tomcat如何实现非阻塞I/O？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/02"><span>15 | Nio2Endpoint组件：Tomcat如何实现异步I/O？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/03"><span>16 | AprEndpoint组件：Tomcat APR提高I/O性能的秘密</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/04"><span>17 | Executor组件：Tomcat如何扩展Java线程池？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/05"><span>18 | 新特性：Tomcat如何支持WebSocket？</span></a></li><li><a aria-current="page" class="active" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06"><span>19 | 比较：Jetty的线程策略EatWhatYouKill</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/07"><span>20 | 总结：Tomcat和Jetty中的对象池技术</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/08"><span>21 | 总结：Tomcat和Jetty的高性能、高并发之道</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/09"><span>22 | 热点问题答疑（2）：内核如何阻塞与唤醒进程？</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器">05.模块四容器</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/01"><span>23 | Host容器：Tomcat如何实现热部署和热加载？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/02"><span>24 | Context容器（上）：Tomcat如何打破双亲委托机制？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/03"><span>25 | Context容器（中）：Tomcat如何隔离Web应用？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/04"><span>26 | Context容器（下）：Tomcat如何实现Servlet规范？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/05"><span>27 | 新特性：Tomcat如何支持异步Servlet？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/06"><span>28 | 新特性：Spring Boot如何使用内嵌式的Tomcat和Jetty？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/07"><span>29 | 比较：Jetty如何实现具有上下文信息的责任链？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/05.模块四容器/08"><span>30 | 热点问题答疑（3）：Spring框架中的设计模式</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/06.模块五通用组件">06.模块五通用组件</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/06.模块五通用组件/01"><span>31 | Logger组件：Tomcat的日志框架及实战</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/06.模块五通用组件/02"><span>32 | Manager组件：Tomcat的Session管理机制解析</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/06.模块五通用组件/03"><span>33 | Cluster组件：Tomcat的集群通信原理</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/06.模块五通用组件/04"><span>特别放送 | 如何持续保持对学习的兴趣？</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化">07.模块六性能优化</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/01"><span>34 | JVM GC原理及调优的基本思路</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/02"><span>35 | 如何监控Tomcat的性能？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/03"><span>36 | Tomcat I/O和线程池的并发调优</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/04"><span>37 | Tomcat内存溢出的原因分析及调优</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/05"><span>38 | Tomcat拒绝连接原因分析及网络优化</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/06"><span>39 | Tomcat进程占用CPU过高怎么办？</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/07"><span>40 | 谈谈Jetty性能调优的思路</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/07.模块六性能优化/08"><span>41 | 热点问题答疑（4）： Tomcat和Jetty有哪些不同？</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/08.结束语">08.结束语</a><ul><li><a href="/blog-architect3/深入拆解tomcat和jetty/08.结束语/01"><span>结束语 | 静下心来，品味经典</span></a></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/08.结束语/02"><span>结课测试 | 这些Tomcat&amp;Jetty的知识你都掌握了吗？</span></a></li></ul></li><li><a href="/blog-architect3/深入拆解tomcat和jetty/summary">深入拆解tomcat和jetty</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="Selector编程的一般思路" data-depth="2"><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#selector编程的一般思路"><span>Selector编程的一般思路</span></a></li><li title="Jetty中的Selector编程" data-depth="2"><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#jetty中的selector编程"><span>Jetty中的Selector编程</span></a></li><li title="本期精华" data-depth="2"><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#本期精华"><span>本期精华</span></a></li><li title="课后思考" data-depth="2"><a href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#课后思考"><span>课后思考</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="19--比较jetty的线程策略eatwhatyoukill"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#19--比较jetty的线程策略eatwhatyoukill"><span class="icon icon-link"></span></a>19 | 比较：Jetty的线程策略EatWhatYouKill</h1><p>我在前面的专栏里介绍了Jetty的总体架构设计，简单回顾一下，Jetty总体上是由一系列Connector、一系列Handler和一个ThreadPool组成，它们的关系如下图所示：</p><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimage9b419b0e08e109f41b1c02b9f324c0a71241.5821aa62.jpg" alt=""/></p><p>相比较Tomcat的连接器，Jetty的Connector在设计上有自己的特点。Jetty的Connector支持NIO通信模型，我们知道<strong>NIO模型中的主角就是Selector</strong>，Jetty在Java原生Selector的基础上封装了自己的Selector，叫作ManagedSelector。ManagedSelector在线程策略方面做了大胆尝试，将I/O事件的侦测和处理放到同一个线程来处理，充分利用了CPU缓存并减少了线程上下文切换的开销。</p><p>具体的数字是，根据Jetty的官方测试，这种名为“EatWhatYouKill”的线程策略将吞吐量提高了8倍。你一定很好奇它是如何实现的吧，今天我们就来看一看这背后的原理是什么。</p><h2 id="selector编程的一般思路"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#selector编程的一般思路"><span class="icon icon-link"></span></a>Selector编程的一般思路</h2><p>常规的NIO编程思路是，将I/O事件的侦测和请求的处理分别用不同的线程处理。具体过程是：</p><p>启动一个线程，在一个死循环里不断地调用select方法，检测Channel的I/O状态，一旦I/O事件达到，比如数据就绪，就把该I/O事件以及一些数据包装成一个Runnable，将Runnable放到新线程中去处理。</p><p>在这个过程中按照职责划分，有两个线程在干活，一个是I/O事件检测线程，另一个是I/O事件处理线程。我们仔细思考一下这两者的关系，其实它们是生产者和消费者的关系。I/O事件侦测线程作为生产者，负责“生产”I/O事件，也就是负责接活儿的老板；I/O处理线程是消费者，它“消费”并处理I/O事件，就是干苦力的员工。把这两个工作用不同的线程来处理，好处是它们互不干扰和阻塞对方。</p><h2 id="jetty中的selector编程"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#jetty中的selector编程"><span class="icon icon-link"></span></a>Jetty中的Selector编程</h2><p>然而世事无绝对，将I/O事件检测和业务处理这两种工作分开的思路也有缺点。当Selector检测读就绪事件时，数据已经被拷贝到内核中的缓存了，同时CPU的缓存中也有这些数据了，我们知道CPU本身的缓存比内存快多了，这时当应用程序去读取这些数据时，如果用另一个线程去读，很有可能这个读线程使用另一个CPU核，而不是之前那个检测数据就绪的CPU核，这样CPU缓存中的数据就用不上了，并且线程切换也需要开销。</p><p>因此Jetty的Connector做了一个大胆尝试，那就是用<strong>把I/O事件的生产和消费放到同一个线程来处理</strong>，如果这两个任务由同一个线程来执行，如果执行过程中线程不阻塞，操作系统会用同一个CPU核来执行这两个任务，这样就能利用CPU缓存了。那具体是如何做的呢，我们还是来详细分析一下Connector中的ManagedSelector组件。</p><p><strong>ManagedSelector</strong></p><p>ManagedSelector的本质就是一个Selector，负责I/O事件的检测和分发。为了方便使用，Jetty在Java原生的Selector上做了一些扩展，就变成了ManagedSelector，我们先来看看它有哪些成员变量：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public class ManagedSelector extends ContainerLifeCycle implements Dumpable</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //原子变量，表明当前的ManagedSelector是否已经启动</span></div><div class="token-line"><span class="token plain">        private final AtomicBoolean _started = new AtomicBoolean(false);</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //表明是否阻塞在select调用上</span></div><div class="token-line"><span class="token plain">        private boolean _selecting = false;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //管理器的引用，SelectorManager管理若干ManagedSelector的生命周期</span></div><div class="token-line"><span class="token plain">        private final SelectorManager _selectorManager;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //ManagedSelector不止一个，为它们每人分配一个id</span></div><div class="token-line"><span class="token plain">        private final int _id;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //关键的执行策略，生产者和消费者是否在同一个线程处理由它决定</span></div><div class="token-line"><span class="token plain">        private final ExecutionStrategy _strategy;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //Java原生的Selector</span></div><div class="token-line"><span class="token plain">        private Selector _selector;</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //&quot;Selector更新任务&quot;队列</span></div><div class="token-line"><span class="token plain">        private Deque&lt;SelectorUpdate&gt; _updates = new ArrayDeque&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        private Deque&lt;SelectorUpdate&gt; _updateable = new ArrayDeque&lt;&gt;();</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        ...</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这些成员变量中其他的都好理解，就是“Selector更新任务”队列<code>_updates</code>和执行策略<code>_strategy</code>可能不是很直观。</p><p><strong>SelectorUpdate接口</strong></p><p>为什么需要一个“Selector更新任务”队列呢，对于Selector的用户来说，我们对Selector的操作无非是将Channel注册到Selector或者告诉Selector我对什么I/O事件感兴趣，那么这些操作其实就是对Selector状态的更新，Jetty把这些操作抽象成SelectorUpdate接口。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">/**</span></div><div class="token-line"><span class="token plain">     * A selector update to be done when the selector has been woken.</span></div><div class="token-line"><span class="token plain">     */</span></div><div class="token-line"><span class="token plain">    public interface SelectorUpdate</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        void update(Selector selector);</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>这意味着如果你不能直接操作ManageSelector中的Selector，而是需要向ManagedSelector提交一个任务类，这个类需要实现SelectorUpdate接口update方法，在update方法里定义你想要对ManagedSelector做的操作。</p><p>比如Connector中Endpoint组件对读就绪事件感兴趣，它就向ManagedSelector提交了一个内部任务类ManagedSelector.SelectorUpdate：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">_selector.submit(_updateKeyAction);</span></div></pre></div><p>这个<code>_updateKeyAction</code>就是一个SelectorUpdate实例，它的update方法实现如下：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private final ManagedSelector.SelectorUpdate _updateKeyAction = new ManagedSelector.SelectorUpdate()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public void update(Selector selector)</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //这里的updateKey其实就是调用了SelectionKey.interestOps(OP_READ);</span></div><div class="token-line"><span class="token plain">            updateKey();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    };</span></div></pre></div><p>我们看到在update方法里，调用了SelectionKey类的interestOps方法，传入的参数是<code>OP_READ</code>，意思是现在我对这个Channel上的读就绪事件感兴趣了。</p><p>那谁来负责执行这些update方法呢，答案是ManagedSelector自己，它在一个死循环里拉取这些SelectorUpdate任务类逐个执行。</p><p><strong>Selectable接口</strong></p><p>那I/O事件到达时，ManagedSelector怎么知道应该调哪个函数来处理呢？其实也是通过一个任务类接口，这个接口就是Selectable，它返回一个Runnable，这个Runnable其实就是I/O事件就绪时相应的处理逻辑。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public interface Selectable</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //当某一个Channel的I/O事件就绪后，ManagedSelector会调用的回调函数</span></div><div class="token-line"><span class="token plain">        Runnable onSelected();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //当所有事件处理完了之后ManagedSelector会调的回调函数，我们先忽略。</span></div><div class="token-line"><span class="token plain">        void updateKey();</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>ManagedSelector在检测到某个Channel上的I/O事件就绪时，也就是说这个Channel被选中了，ManagedSelector调用这个Channel所绑定的附件类的onSelected方法来拿到一个Runnable。</p><p>这句话有点绕，其实就是ManagedSelector的使用者，比如Endpoint组件在向ManagedSelector注册读就绪事件时，同时也要告诉ManagedSelector在事件就绪时执行什么任务，具体来说就是传入一个附件类，这个附件类需要实现Selectable接口。ManagedSelector通过调用这个onSelected拿到一个Runnable，然后把Runnable扔给线程池去执行。</p><p>那Endpoint的onSelected是如何实现的呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">@Override</span></div><div class="token-line"><span class="token plain">    public Runnable onSelected()</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        int readyOps = _key.readyOps();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        boolean fillable = (readyOps &amp; SelectionKey.OP_READ) != 0;</span></div><div class="token-line"><span class="token plain">        boolean flushable = (readyOps &amp; SelectionKey.OP_WRITE) != 0;</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        // return task to complete the job</span></div><div class="token-line"><span class="token plain">        Runnable task= fillable </span></div><div class="token-line"><span class="token plain">                ? (flushable </span></div><div class="token-line"><span class="token plain">                        ? _runCompleteWriteFillable </span></div><div class="token-line"><span class="token plain">                        : _runFillable)</span></div><div class="token-line"><span class="token plain">                : (flushable </span></div><div class="token-line"><span class="token plain">                        ? _runCompleteWrite </span></div><div class="token-line"><span class="token plain">                        : null);</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        return task;</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>上面的代码逻辑很简单，就是读事件到了就读，写事件到了就写。</p><p><strong>ExecutionStrategy</strong></p><p>铺垫了这么多，终于要上主菜了。前面我主要介绍了ManagedSelector的使用者如何跟ManagedSelector交互，也就是如何注册Channel以及I/O事件，提供什么样的处理类来处理I/O事件，接下来我们来看看ManagedSelector是如何统一管理和维护用户注册的Channel集合。再回到今天开始的讨论，ManagedSelector将I/O事件的生产和消费看作是生产者消费者模式，为了充分利用CPU缓存，生产和消费尽量放到同一个线程处理，那这是如何实现的呢？Jetty定义了ExecutionStrategy接口：</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public interface ExecutionStrategy</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        //只在HTTP2中用到，简单起见，我们先忽略这个方法。</span></div><div class="token-line"><span class="token plain">        public void dispatch();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        //实现具体执行策略，任务生产出来后可能由当前线程执行，也可能由新线程来执行</span></div><div class="token-line"><span class="token plain">        public void produce();</span></div><div class="token-line"><span class="token plain">        </span></div><div class="token-line"><span class="token plain">        //任务的生产委托给Producer内部接口，</span></div><div class="token-line"><span class="token plain">        public interface Producer</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            //生产一个Runnable(任务)</span></div><div class="token-line"><span class="token plain">            Runnable produce();</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>我们看到ExecutionStrategy接口比较简单，它将具体任务的生产委托内部接口Producer，而在自己的produce方法里来实现具体执行逻辑，<strong>也就是生产出来的任务要么由当前线程执行，要么放到新线程中执行</strong>。Jetty提供了一些具体策略实现类：ProduceConsume、ProduceExecuteConsume、ExecuteProduceConsume和EatWhatYouKill。它们的区别是：</p><ul><li>ProduceConsume：任务生产者自己依次生产和执行任务，对应到NIO通信模型就是用一个线程来侦测和处理一个ManagedSelector上所有的I/O事件，后面的I/O事件要等待前面的I/O事件处理完，效率明显不高。通过图来理解，图中绿色表示生产一个任务，蓝色表示执行这个任务。</li></ul><p><img src="data:image/jpeg;base64,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" alt=""/></p><ul><li>ProduceExecuteConsume：任务生产者开启新线程来运行任务，这是典型的I/O事件侦测和处理用不同的线程来处理，缺点是不能利用CPU缓存，并且线程切换成本高。同样我们通过一张图来理解，图中的棕色表示线程切换。</li></ul><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimage7e6d7e50ce9ec1bff55bbec777e79271066d.f40ea761.png" alt=""/></p><ul><li>ExecuteProduceConsume：任务生产者自己运行任务，但是该策略可能会新建一个新线程以继续生产和执行任务。这种策略也被称为“吃掉你杀的猎物”，它来自狩猎伦理，认为一个人不应该杀死他不吃掉的东西，对应线程来说，不应该生成自己不打算运行的任务。它的优点是能利用CPU缓存，但是潜在的问题是如果处理I/O事件的业务代码执行时间过长，会导致线程大量阻塞和线程饥饿。</li></ul><p><img src="/blog-architect3/static/httpsstatic001geekbangorgresourceimage43b443c2dadaf5c323edf057a90ff06a71b4.edb87b71.png" alt=""/></p><ul><li>EatWhatYouKill：这是Jetty对ExecuteProduceConsume策略的改良，在线程池线程充足的情况下等同于ExecuteProduceConsume；当系统比较忙线程不够时，切换成ProduceExecuteConsume策略。为什么要这么做呢，原因是ExecuteProduceConsume是在同一线程执行I/O事件的生产和消费，它使用的线程来自Jetty全局的线程池，这些线程有可能被业务代码阻塞，如果阻塞得多了，全局线程池中的线程自然就不够用了，最坏的情况是连I/O事件的侦测都没有线程可用了，会导致Connector拒绝浏览器请求。于是Jetty做了一个优化，在低线程情况下，就执行ProduceExecuteConsume策略，I/O侦测用专门的线程处理，I/O事件的处理扔给线程池处理，其实就是放到线程池的队列里慢慢处理。</li></ul><p>分析了这几种线程策略，我们再来看看Jetty是如何实现ExecutionStrategy接口的。答案其实就是实现Produce接口生产任务，一旦任务生产出来，ExecutionStrategy会负责执行这个任务。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">private class SelectorProducer implements ExecutionStrategy.Producer</span></div><div class="token-line"><span class="token plain">    {</span></div><div class="token-line"><span class="token plain">        private Set&lt;SelectionKey&gt; _keys = Collections.emptySet();</span></div><div class="token-line"><span class="token plain">        private Iterator&lt;SelectionKey&gt; _cursor = Collections.emptyIterator();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">        @Override</span></div><div class="token-line"><span class="token plain">        public Runnable produce()</span></div><div class="token-line"><span class="token plain">        {</span></div><div class="token-line"><span class="token plain">            while (true)</span></div><div class="token-line"><span class="token plain">            {</span></div><div class="token-line"><span class="token plain">                //如何Channel集合中有I/O事件就绪，调用前面提到的Selectable接口获取Runnable,直接返回给ExecutionStrategy去处理</span></div><div class="token-line"><span class="token plain">                Runnable task = processSelected();</span></div><div class="token-line"><span class="token plain">                if (task != null)</span></div><div class="token-line"><span class="token plain">                    return task;</span></div><div class="token-line"><span class="token plain">                </span></div><div class="token-line"><span class="token plain">               //如果没有I/O事件就绪，就干点杂活，看看有没有客户提交了更新Selector的任务，就是上面提到的SelectorUpdate任务类。</span></div><div class="token-line"><span class="token plain">                processUpdates();</span></div><div class="token-line"><span class="token plain">                updateKeys();</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">               //继续执行select方法，侦测I/O就绪事件</span></div><div class="token-line"><span class="token plain">                if (!select())</span></div><div class="token-line"><span class="token plain">                    return null;</span></div><div class="token-line"><span class="token plain">            }</span></div><div class="token-line"><span class="token plain">        }</span></div><div class="token-line"><span class="token plain">     }</span></div></pre></div><p>SelectorProducer是ManagedSelector的内部类，SelectorProducer实现了ExecutionStrategy中的Producer接口中的produce方法，需要向ExecutionStrategy返回一个Runnable。在这个方法里SelectorProducer主要干了三件事情</p><ol><li>如果Channel集合中有I/O事件就绪，调用前面提到的Selectable接口获取Runnable，直接返回给ExecutionStrategy去处理。</li><li>如果没有I/O事件就绪，就干点杂活，看看有没有客户提交了更新Selector上事件注册的任务，也就是上面提到的SelectorUpdate任务类。</li><li>干完杂活继续执行select方法，侦测I/O就绪事件。</li></ol><h2 id="本期精华"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#本期精华"><span class="icon icon-link"></span></a>本期精华</h2><p>多线程虽然是提高并发的法宝，但并不是说线程越多越好，CPU缓存以及线程上下文切换的开销也是需要考虑的。Jetty巧妙设计了EatWhatYouKill的线程策略，尽量用同一个线程侦测I/O事件和处理I/O事件，充分利用了CPU缓存，并减少了线程切换的开销。</p><h2 id="课后思考"><a aria-hidden="true" tabindex="-1" href="/blog-architect3/深入拆解tomcat和jetty/04.模块三连接器/06#课后思考"><span class="icon icon-link"></span></a>课后思考</h2><p>文章提到ManagedSelector的使用者不能直接向它注册I/O事件，而是需要向ManagedSelector提交一个SelectorUpdate事件，ManagedSelector将这些事件Queue起来由自己来统一处理，这样做有什么好处呢？</p><p>不知道今天的内容你消化得如何？如果还有疑问，请大胆的在留言区提问，也欢迎你把你的课后思考和心得记录下来，与我和其他同学一起讨论。如果你觉得今天有所收获，欢迎你把它分享给你的朋友。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/深入拆解tomcat和jetty/04.模块三连接器/06.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/29 14:48:00</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-architect3/umi.0a9ffe80.js"></script>
  </body>
</html>
